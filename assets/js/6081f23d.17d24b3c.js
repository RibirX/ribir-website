"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[333],{9740:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=t(4848),s=t(8453);const r={sidebar_position:2},a="Quick Start",o={id:"get_started/quick_start",title:"Quick Start",description:"This chapter will introduce you to all the syntax and common basic concepts of Ribir.",source:"@site/docs/get_started/quick_start.md",sourceDirName:"get_started",slug:"/get_started/quick_start",permalink:"/docs/next/get_started/quick_start",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1751877953e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Try Ribir",permalink:"/docs/next/get_started/try_it"},next:{title:"Practice Todos App",permalink:"/docs/next/category/practice-todos-app"}},d={},c=[{value:"What is a widget?",id:"what-is-a-widget",level:2},{value:"Function widget",id:"function-widget",level:2},{value:"Defining widgets through function",id:"defining-widgets-through-function",level:3},{value:"Closures and <code>fn_widget!</code>",id:"closures-and-fn_widget",level:3},{value:"Using <code>rdl!</code> to Create Objects",id:"using-rdl-to-create-objects",level:2},{value:"Declaratively Creating Objects",id:"declaratively-creating-objects",level:3},{value:"Expression-Based Object Creation",id:"expression-based-object-creation",level:3},{value:"Composing Widgets",id:"composing-widgets",level:3},{value:"<code>@</code> Syntactic Sugar",id:"-syntactic-sugar",level:2},{value:"State - Making Data Watchable and Shareable",id:"state---making-data-watchable-and-shareable",level:2},{value:"$ Syntactic Sugar",id:"-syntactic-sugar-1",level:2},{value:"State Read and Write References",id:"state-read-and-write-references",level:3},{value:"Automatic Sharing of States",id:"automatic-sharing-of-states",level:3},{value:"Priority of Syntactic Sugar Expansion",id:"priority-of-syntactic-sugar-expansion",level:3},{value:"<code>Pipe</code> stream -- keep responding to data",id:"pipe-stream----keep-responding-to-data",level:2},{value:"Rendering widgets dynamically",id:"rendering-widgets-dynamically",level:3},{value:"Try to keep <code>pipe!</code> to the smallest possible expression.",id:"try-to-keep-pipe-to-the-smallest-possible-expression",level:3},{value:"Operators for rxRust on <code>Pipe</code> chains",id:"operators-for-rxrust-on-pipe-chains",level:3},{value:"Listening for expression changes with <code>watch!</code>",id:"listening-for-expression-changes-with-watch",level:2},{value:"<code>Compose</code> widget - describing your data structure",id:"compose-widget---describing-your-data-structure",level:2},{value:"Built-in widgets",id:"built-in-widgets",level:2},{value:"State Transitions, Separation, and Traceability",id:"state-transitions-separation-and-traceability",level:2},{value:"Transitions and Separation, converting states into sub-states",id:"transitions-and-separation-converting-states-into-sub-states",level:3},{value:"The next step",id:"the-next-step",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"quick-start",children:"Quick Start"}),"\n",(0,i.jsx)(n.p,{children:"This chapter will introduce you to all the syntax and common basic concepts of Ribir."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"You will learn"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"How to create and compose widgets"}),"\n",(0,i.jsx)(n.li,{children:"How to respond to events and manipulate data"}),"\n",(0,i.jsx)(n.li,{children:"How to make views automatically respond to data changes"}),"\n",(0,i.jsx)(n.li,{children:"How to build dynamic widgets"}),"\n",(0,i.jsx)(n.li,{children:"How to map your own data structures to views"}),"\n",(0,i.jsx)(n.li,{children:"How to use built-in widgets as part of other widgets"}),"\n",(0,i.jsx)(n.li,{children:"How to transform, separate, and trace the state \u2014 facilitating state transfer and controlling the scope of view updates"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"what-is-a-widget",children:"What is a widget?"}),"\n",(0,i.jsx)(n.p,{children:"In Ribir, a widget is the basic unit that describes a view. It can be a button, a text box, a list, a dialog, or even the entire application interface. In code, it can be a function, a closure, or a data object."}),"\n",(0,i.jsx)(n.p,{children:"If you don't quite understand the above, don't worry, because you don't need to focus on the widget construction process, and Ribir prohibits interference in this process. You just need to understand that Ribir divides all widgets into four categories:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"function widget"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Compose"})," widget"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Render"})," widget"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ComposeChild"})," widget"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This chapter will only introduce function widgets and ",(0,i.jsx)(n.code,{children:"Compose"})," widgets. Because in most scenarios, these two types of widgets are sufficient to meet our needs. As advanced content, we will cover ",(0,i.jsx)(n.code,{children:"Render"})," widgets and ",(0,i.jsx)(n.code,{children:"ComposeChild"})," widgets in ",(0,i.jsx)(n.a,{href:"/docs/next/understanding_ribir/widget_in_depth",children:"Widgets In-depth"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Please note the difference between ",(0,i.jsx)(n.code,{children:"Widget"})," and widget in the entire context of Ribir. Widget is a generic term, while the capitalized ",(0,i.jsx)(n.code,{children:"Widget"})," is a specific widget, also the pass for all widgets to enter the view."]}),"\n",(0,i.jsx)(n.h2,{id:"function-widget",children:"Function widget"}),"\n",(0,i.jsxs)(n.p,{children:["A function or closure that returns a ",(0,i.jsx)(n.code,{children:"Widget"})," is called a function widget. A function widget that can be called multiple times can be transformed into a ",(0,i.jsx)(n.code,{children:"GenWidget"}),", and the root widget of our application requires a ",(0,i.jsx)(n.code,{children:"GenWidget"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Defining widgets through functions is the simplest and fastest way. In ",(0,i.jsx)(n.a,{href:"/docs/next/get_started/try_it",children:"Try Ribir"}),", you have already seen an example of a ",(0,i.jsx)(n.code,{children:"Hello World!"})," function widget. In this section, we will continue the introduction using the ",(0,i.jsx)(n.code,{children:"Hello World!"})," example."]}),"\n",(0,i.jsx)(n.h3,{id:"defining-widgets-through-function",children:"Defining widgets through function"}),"\n",(0,i.jsxs)(n.p,{children:["Let's start by defining a ",(0,i.jsx)(n.code,{children:"hello_world"})," function to complete our example."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn hello_world() -> Widget<\'static> {\n  let mut text = Text::declarer();\n  text.with_text("Hello World!");\n  text.finish().into_widget()\n}\n\nfn main() { \n  App::run(hello_world);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Because the ",(0,i.jsx)(n.code,{children:"Text"})," widget only provides a declarative API creation method, we need to create its declarer with ",(0,i.jsx)(n.code,{children:"Text::declarer()"})," and finish the creation with ",(0,i.jsx)(n.code,{children:"finish()"}),". Then, we convert it to a ",(0,i.jsx)(n.code,{children:"Widget"})," type using ",(0,i.jsx)(n.code,{children:"into_widget()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For declarative widgets, we can also simplify their writing with ",(0,i.jsx)(n.code,{children:"rdl!"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn hello_world() -> Widget<\'static> {\n  rdl!{ Text { text: "Hello World!" } }\n    .into_widget()\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We will delve into the details of ",(0,i.jsx)(n.code,{children:"rdl!"})," in the section ",(0,i.jsxs)(n.a,{href:"#using-rdl-to-create-objects",children:["Using ",(0,i.jsx)(n.code,{children:"rdl!"})," to Create Objects"]}),". For now, let's put it aside."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Tip"}),"\n",(0,i.jsxs)(n.p,{children:["The framework automatically implements the ",(0,i.jsx)(n.code,{children:"into_widget"})," method for all types of widgets."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"closures-and-fn_widget",children:["Closures and ",(0,i.jsx)(n.code,{children:"fn_widget!"})]}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"hello_world"})," is not called by anyone else, you can rewrite it as a closure:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  let hello_world = || {\n    rdl!{ Text { text: "Hello World!" } }\n      .into_widget()\n  };\n  App::run(hello_world);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For creating function widgets through closures, Ribir provides a ",(0,i.jsx)(n.code,{children:"fn_widget!"})," macro to simplify this process. Apart from supporting the two syntactic sugars ",(0,i.jsx)(n.code,{children:"@"})," and ",(0,i.jsx)(n.code,{children:"$"})," that we will talk about next in this chapter, you can think of ",(0,i.jsx)(n.code,{children:"fn_widget!"})," as expanding the code like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"move || -> Widget {\n  {\n    // Your code\n  }\n  .into_widget()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"fn_widget!"})," to rewrite the ",(0,i.jsx)(n.code,{children:"hello_world"})," example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! { \n    rdl!{ Text { text: "Hello World!" } }\n  });\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Usually, declarative widgets provide a macro of the same name, which creates a function widget rooted in itself using ",(0,i.jsx)(n.code,{children:"fn_widget!"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"So, our example can be further simplified to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(text! { text: "Hello World!"});\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This is the example we saw in ",(0,i.jsx)(n.a,{href:"/docs/next/get_started/try_it",children:"Try Ribir"}),"."]}),"\n",(0,i.jsxs)(n.h2,{id:"using-rdl-to-create-objects",children:["Using ",(0,i.jsx)(n.code,{children:"rdl!"})," to Create Objects"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rdl"})," stands for Ribir Declarative Language, and the ",(0,i.jsx)(n.code,{children:"rdl!"})," macro aims to help you create objects in a declarative way."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Tips"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rdl!"})," does not care about types, it only processes syntax at the language level, so it is not limited to widgets only."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"declaratively-creating-objects",children:"Declaratively Creating Objects"}),"\n",(0,i.jsxs)(n.p,{children:["Although ",(0,i.jsx)(n.code,{children:"rdl!"})," supports any Rust expression, when we talk about declarative object creation, we specifically refer to creating objects through struct literals:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"rdl! { \n  ObjectType {\n    ... // Field declarations\n  } \n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When your expression is a struct literal, ",(0,i.jsx)(n.code,{children:"rdl!"})," creates objects using the ",(0,i.jsx)(n.code,{children:"Declare"})," trait, which requires the object type you create to inherit or implement the ",(0,i.jsx)(n.code,{children:"Declare"})," trait."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use ribir::prelude::*;\n\n#[derive(Declare)]\npub struct Counter {\n  #[declare(default = 1usize)]\n  count: usize,\n}\n\nfn use_rdl() {\n  let _ = rdl!{ Counter { } };\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, ",(0,i.jsx)(n.code,{children:"Counter"})," inherits ",(0,i.jsx)(n.code,{children:"Declare"})," and marks ",(0,i.jsx)(n.code,{children:"count"})," with a default value of ",(0,i.jsx)(n.code,{children:"1"}),". Therefore, in ",(0,i.jsx)(n.code,{children:"rdl!"}),", you don't need to assign a value to ",(0,i.jsx)(n.code,{children:"count"}),", as ",(0,i.jsx)(n.code,{children:"rdl!"})," will default it to ",(0,i.jsx)(n.code,{children:"1"}),". ",(0,i.jsx)(n.code,{children:"Declare"})," has some other features, but we won't delve into them here."]}),"\n",(0,i.jsx)(n.h3,{id:"expression-based-object-creation",children:"Expression-Based Object Creation"}),"\n",(0,i.jsxs)(n.p,{children:["Besides creating objects through struct literals, you can also place any expression inside ",(0,i.jsx)(n.code,{children:"rdl!"}),". This is useful when dealing with nested compositions, and it is only necessary when nesting as children. The following example shows how to use expressions to create objects in ",(0,i.jsx)(n.code,{children:"rdl"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nlet _parent = rdl!{\n  // You can write any expression here, and the result of the expression will be the child\n  if  {\n    ...\n  } else {\n    ...\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"composing-widgets",children:"Composing Widgets"}),"\n",(0,i.jsxs)(n.p,{children:["Now that you know how to create widgets in ",(0,i.jsx)(n.code,{children:"rdl!"}),", let's compose widgets to create a simple counter application."]}),"\n",(0,i.jsxs)(n.p,{children:["You can nest widgets within struct literal declarations to create children using ",(0,i.jsx)(n.code,{children:"rdl!"}),". Note that children are always required to be declared after their parent widget fields, which is a format requirement enforced by ",(0,i.jsx)(n.code,{children:"rdl!"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  let counter = fn_widget! { \n    rdl!{ \n      Button {\n        rdl!{ "0" }\n      }\n    }\n  };\n\n  App::run(counter);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, we created a ",(0,i.jsx)(n.code,{children:"Button"})," and composed it with a string as a child. ",(0,i.jsx)(n.code,{children:"Button"})," is already defined in the ",(0,i.jsx)(n.code,{children:"ribir_widgets"})," library."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rdl!"})," also allows you to declare children for widgets that have already been created:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  let counter = fn_widget! {\n    let btn = rdl! { Button {} };\n    rdl!{ \n      (btn) {\n        rdl!{ "0" }\n      }\n    }\n  };\n\n  App::run(counter);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Notice the ",(0,i.jsx)(n.code,{children:"rdl!{ $btn { ... } }"})," syntax? Similar to struct literal syntax, but with ",(0,i.jsx)(n.code,{children:"$"})," in front, it indicates that the parent is a variable rather than a type, so it doesn't create a new widget but directly uses that variable to compose with the child."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Tips"}),"\n",(0,i.jsxs)(n.p,{children:["In Ribir, the composition of parent and child is not arbitrary but is restricted by type, ensuring the correctness of the composition.\nIn our example, ",(0,i.jsx)(n.code,{children:"Button"})," specifies that it can accept two optional children: a string as a label and a ",(0,i.jsx)(n.code,{children:"Widget"})," as an icon.\n",(0,i.jsx)(n.strong,{children:"Why is the label of the Button designed to be a child rather than its own field?"})," This is because, if it were a field of ",(0,i.jsx)(n.code,{children:"Button"}),", it would occupy memory regardless of whether ",(0,i.jsx)(n.code,{children:"Button"})," has a label or not. By making it a child, there is no memory overhead for this field when the Button doesn't have a label."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["We will delve into how to constrain the type of children for widgets in ",(0,i.jsx)(n.a,{href:"/docs/next/understanding_ribir/widget_in_depth",children:"Understanding Ribir"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"-syntactic-sugar",children:[(0,i.jsx)(n.code,{children:"@"})," Syntactic Sugar"]}),"\n",(0,i.jsxs)(n.p,{children:["In the process of compose widgets, we used multiple ",(0,i.jsx)(n.code,{children:"rdl!"}),". On one hand, it helps us have a clear declarative structure when interacting with Rust syntax (especially in complex examples) - when you see ",(0,i.jsx)(n.code,{children:"rdl!"}),", you know that the composition or creation of a widget node has begun; on the other hand, when every node is wrapped with ",(0,i.jsx)(n.code,{children:"rdl!"}),", it may appear too verbose, making it hard to see the key information."]}),"\n",(0,i.jsxs)(n.p,{children:["Fortunately, Ribir provides an ",(0,i.jsx)(n.code,{children:"@"})," syntactic sugar for ",(0,i.jsx)(n.code,{children:"rdl!"}),", and in actual use, you mostly use ",(0,i.jsx)(n.code,{children:"@"})," instead of ",(0,i.jsx)(n.code,{children:"rdl!"}),". There are three main cases:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@Button {...}"})," as a struct literal's syntactic sugar, expands to ",(0,i.jsx)(n.code,{children:"rdl!{ Button {...} }"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@ $btn {...}"})," as syntactic sugar for variable struct literals, expands to ",(0,i.jsx)(n.code,{children:"rdl!{ $btn {...} }"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@ { ... }"})," is syntactic sugar for expressions, expanding to ",(0,i.jsx)(n.code,{children:"rdl!{ ... }"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Now, let's rewrite the above counter example using ",(0,i.jsx)(n.code,{children:"@"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    @Button {\n      @ { "0" }\n    }\n  });\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"state---making-data-watchable-and-shareable",children:"State - Making Data Watchable and Shareable"}),"\n",(0,i.jsxs)(n.p,{children:["Although we have created a counter, it always displays ",(0,i.jsx)(n.code,{children:"0"}),", and clicking the button does not do anything. In this section, you will learn how to make your counter work using state."]}),"\n",(0,i.jsx)(n.p,{children:"State is a wrapper that makes data watchable and shareable."}),"\n",(0,i.jsx)(n.p,{children:"The complete lifecycle of an interactive Ribir widget is as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Convert your data into state."}),"\n",(0,i.jsx)(n.li,{children:"Declare a mapping from state to view to build the view."}),"\n",(0,i.jsx)(n.li,{children:"During interaction, modify the data through state."}),"\n",(0,i.jsx)(n.li,{children:"Receive data changes through state and update the view point-to-point based on the mapping."}),"\n",(0,i.jsx)(n.li,{children:"Repeat steps 3 and 4."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Now, let's introduce state to transform our example."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // Change 1: Create a state using `State::value`\n    let count = State::value(0);\n    @Button {\n      // Change 2: Modify the state on tap\n      on_tap: move |_| *$write(count) += 1,\n      // Change 3: Display data using state and keep the view updated.\n      // For macros or function calls, you can omit the curly braces after `@`\n      @ pipe!($read(count).to_string())\n    }\n  });\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["By making these 3 changes, the small counter example is complete. However, in changes 2 and 3, new elements are introduced \u2014 ",(0,i.jsx)(n.code,{children:"$"})," and ",(0,i.jsx)(n.code,{children:"pipe!"}),". They are crucial in Ribir, and understanding them will help you work effectively with state."]}),"\n",(0,i.jsx)(n.h2,{id:"-syntactic-sugar-1",children:"$ Syntactic Sugar"}),"\n",(0,i.jsxs)(n.p,{children:["In Ribir, there are two important syntactic sugars, one is the ",(0,i.jsxs)(n.a,{href:"#-syntactic-sugar",children:[(0,i.jsx)(n.code,{children:"@"})," Syntactic Sugar"]})," introduced earlier, and the other is the ",(0,i.jsx)(n.code,{children:"$"})," syntactic sugar."]}),"\n",(0,i.jsx)(n.h3,{id:"state-read-and-write-references",children:"State Read and Write References"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"$"})," indicates a read or write reference to the state that follows it. For example, ",(0,i.jsx)(n.code,{children:"$count"})," represents a read reference to ",(0,i.jsx)(n.code,{children:"count"}),", and when followed by a ",(0,i.jsx)(n.code,{children:"write()"})," call, it represents a write reference to ",(0,i.jsx)(n.code,{children:"count"}),", such as ",(0,i.jsx)(n.code,{children:"$count.write()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Besides ",(0,i.jsx)(n.code,{children:"write"}),", Ribir also provides a ",(0,i.jsx)(n.code,{children:"silent"})," write reference, where modifying data through ",(0,i.jsx)(n.code,{children:"silent"})," write does not trigger view updates."]}),"\n",(0,i.jsxs)(n.p,{children:["The expansion logic of state's ",(0,i.jsx)(n.code,{children:"$"})," syntactic sugar is as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$counter.write()"})," expands to ",(0,i.jsx)(n.code,{children:"counter.write()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$counter.silent()"})," expands to ",(0,i.jsx)(n.code,{children:"counter.silent()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$counter"})," expands to ",(0,i.jsx)(n.code,{children:"counter.read()"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"automatic-sharing-of-states",children:"Automatic Sharing of States"}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"$"})," is inside a ",(0,i.jsx)(n.code,{children:"move"})," closure, it points to a cloned version of the state (read/write). The closure captures a clone of the state, allowing you to use the state directly and easily share it without needing to clone it explicitly."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"move |_| *$count.write() += 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expands roughly to"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"{\n  let count = count.clone_writer();\n  move |_| *count.write() += 1\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"priority-of-syntactic-sugar-expansion",children:"Priority of Syntactic Sugar Expansion"}),"\n",(0,i.jsxs)(n.p,{children:["Remember we also used ",(0,i.jsx)(n.code,{children:"$"})," in ",(0,i.jsx)(n.a,{href:"#composing-widgets",children:"Composing Widgets"}),"? For example, ",(0,i.jsx)(n.code,{children:"rdl!{ $btn { ... } }"})," or ",(0,i.jsx)(n.code,{children:"@ $btn { ... }"}),". This is not a reference to state data, as ",(0,i.jsx)(n.code,{children:"rdl!"})," assigns a different semantic meaning to it \u2014 creating a parent widget using a variable declaration."]}),"\n",(0,i.jsxs)(n.p,{children:["Whether it's ",(0,i.jsx)(n.code,{children:"@"})," or ",(0,i.jsx)(n.code,{children:"$"}),", they should first follow the semantics of the macro they are in, and then be considered as Ribir's syntactic sugar. When using ",(0,i.jsx)(n.code,{children:"@"})," or ",(0,i.jsx)(n.code,{children:"$"})," inside an external macro, they no longer act as Ribir's syntactic sugar, as the external macro likely gives them special meanings."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nfn_widget!{\n  user_macro! {\n    // `@` is not a syntactic sugar here, its semantics \n    // depend on the implementation of `user_macro!`\n    @Button { ... }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"pipe-stream----keep-responding-to-data",children:[(0,i.jsx)(n.code,{children:"Pipe"})," stream -- keep responding to data"]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Pipe"})," stream is a continuously updated data stream with an initial value. It can be decomposed into an initial value and an rxRust stream -- the rxRust stream can be subscribed. It is also the only channel for Ribir to update data changes to the view."]}),"\n",(0,i.jsxs)(n.p,{children:["Ribir provides a ",(0,i.jsx)(n.code,{children:"pipe!"})," macro to help you quickly create a ",(0,i.jsx)(n.code,{children:"Pipe"})," stream. It accepts an expression and monitors all states marked with ",(0,i.jsx)(n.code,{children:"$"})," in the expression to trigger the recalculation of the expression."]}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, ",(0,i.jsx)(n.code,{children:"sum"})," is a ",(0,i.jsx)(n.code,{children:"Pipe"})," stream of the sum of ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"}),". Whenever ",(0,i.jsx)(n.code,{children:"a"})," or ",(0,i.jsx)(n.code,{children:"b"})," changes, ",(0,i.jsx)(n.code,{children:"sum"})," can send the latest result to its downstream."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nlet a = State::value(0);\nlet b = State::value(0);\n\nlet sum = pipe!(*$read(a) + *$read(b));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When declaring an object, you can initialize its property with a ",(0,i.jsx)(n.code,{children:"Pipe"})," stream, so that its property will continue to change with this ",(0,i.jsx)(n.code,{children:"Pipe"})," stream. As we have seen in ",(0,i.jsx)(n.a,{href:"#state---making-data-watchable-and-shareable",children:"State - Making Data Watchable and Shareable"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"  @Text { text: pipe!($count.to_string()) }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"rendering-widgets-dynamically",children:"Rendering widgets dynamically"}),"\n",(0,i.jsxs)(n.p,{children:["Up until now, the structure of all the views you've created has been static, with only the properties changing with the data, but the structure of the widgets does not change with the data. In fact, you can also create a continuously changing widget structure through the ",(0,i.jsx)(n.code,{children:"Pipe"})," stream."]}),"\n",(0,i.jsx)(n.p,{children:"Let's say you have a counter, and instead of displaying the number in text, the counter counts the number in little red squares:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"box counter",src:t(4971).A+"",width:"862",height:"414"})}),"\n",(0,i.jsx)(n.p,{children:"Code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\nfn main() {\n  App::run_with_data(\n    || Stateful::new(0),\n    move |cnt: &\'static Stateful<i32>| {\n      row! {\n        @Button {\n          on_tap: move |_| *$write(cnt) += 1,\n          @ { "Increment" }\n        }\n        @ {\n          pipe!(*$read(cnt)).map(move |cnt| {\n            (0..cnt).map(move |_| {\n              @Container {\n                margin: EdgeInsets::all(2.),\n                size: Size::new(10., 10.),\n                background: Color::RED\n              }\n            })\n          })\n        }\n      }\n    },\n  );\n}\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"try-to-keep-pipe-to-the-smallest-possible-expression",children:["Try to keep ",(0,i.jsx)(n.code,{children:"pipe!"})," to the smallest possible expression."]}),"\n",(0,i.jsxs)(n.p,{children:["Although ",(0,i.jsx)(n.code,{children:"pipe!"})," can contain as many expressions as you like, it is recommended that you try to include only the smallest expressions in ",(0,i.jsx)(n.code,{children:"pipe!"})," and then use ",(0,i.jsx)(n.code,{children:"map"})," to complete the transformation. This allows you to see the source of changes in ",(0,i.jsx)(n.code,{children:"pipe!"})," more clearly and avoids unnecessary dependencies in complex expressions. So, the example above writes"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"pipe!(*$counter).map(move |counter| {\n  move || {\n    (0..counter).map(move |_| {\n      @Container {\n        margin: EdgeInsets::all(2.),\n        size: Size::new(10., 10.),\n        background: Color::RED\n      }\n    })\n  }\n})\n"})}),"\n",(0,i.jsx)(n.p,{children:"instead of:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"pipe!{\n  move || {\n    (0..*$counter).map(move |_| {\n      @Container {\n        margin: EdgeInsets::all(2.),\n        size: Size::new(10., 10.),\n        background: Color::RED\n      }\n    })\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"operators-for-rxrust-on-pipe-chains",children:["Operators for rxRust on ",(0,i.jsx)(n.code,{children:"Pipe"})," chains"]}),"\n",(0,i.jsxs)(n.p,{children:["The update push of the ",(0,i.jsx)(n.code,{children:"Pipe"})," stream is built on top of the rxRust stream, so ",(0,i.jsx)(n.code,{children:"Pipe"})," also provides the method ",(0,i.jsx)(n.code,{children:"value_chain"})," that lets you manipulate the rxRust stream. So you can use rxRust operators such as ",(0,i.jsx)(n.code,{children:"filter"}),", ",(0,i.jsx)(n.code,{children:"debounce"})," ",(0,i.jsx)(n.code,{children:"distinct_until_change"})," and so on to reduce the frequency of updates."]}),"\n",(0,i.jsx)(n.p,{children:"Suppose you have a simple auto-summing example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    let a = State::value(0);\n    let b = State::value(0);\n\n    @Column {\n      @Text { text: pipe!($read(a).to_string()) }\n      @Text { text: pipe!($read(b).to_string()) }\n      @Text {\n        text: pipe!((*$read(a) + *$read(b)).to_string())\n          .transform(|s| s.distinct_until_changed().box_it()),\n        on_tap: move |_| {\n          *$write(a) += 1;\n          *$write(b) -= 1;\n        }\n      }\n    }\n  });\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the first two ",(0,i.jsx)(n.code,{children:"Text"}),"s are updated as ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," are modified, even if the values of ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," do not change - e.g., by setting the same values for them. The last ",(0,i.jsx)(n.code,{children:"Text"}),", on the other hand, filters out updates with duplicate values via ",(0,i.jsx)(n.code,{children:"distinct_until_changed"}),", and will only update if the result of the sum of ",(0,i.jsx)(n.code,{children:"a"})," , ",(0,i.jsx)(n.code,{children:"b"})," changes."]}),"\n",(0,i.jsxs)(n.p,{children:["So when we click on the last ",(0,i.jsx)(n.code,{children:"Text"}),", only the first two ",(0,i.jsx)(n.code,{children:"Texts"})," will be marked as updated, and the last ",(0,i.jsx)(n.code,{children:"Text"})," will not."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Tip\nIn general, to find out which part of the view is dynamically changing, you just need to look for where the ",(0,i.jsx)(n.code,{children:"pipe!"})," is."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"listening-for-expression-changes-with-watch",children:["Listening for expression changes with ",(0,i.jsx)(n.code,{children:"watch!"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"watch!"})," is a macro that listens for changes to an expression, takes in an expression, and monitors all of the ",(0,i.jsx)(n.code,{children:"$"}),"-marked state in the expression to trigger a recalculation of the expression and push the latest results to downstream subscribers."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"watch!"})," listens for changes to the expression and has the same syntax as ",(0,i.jsx)(n.code,{children:"pipe!"}),", but ",(0,i.jsx)(n.code,{children:"pipe!"})," is initialized and behaves more like a continuously changing value than a subscribable stream, whereas ",(0,i.jsx)(n.code,{children:"watch!"})," is only a subscribable stream, so ",(0,i.jsx)(n.code,{children:"pipe!"})," can be used as a value to initialize the properties of the widget, whereas ",(0,i.jsx)(n.code,{children:"watch!"})," cannot."]}),"\n",(0,i.jsx)(n.p,{children:"In short:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pipe!"})," = (initial value + rxRust stream)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"watch!"})," = rxRust stream"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["You can also use ",(0,i.jsx)(n.code,{children:"watch!"})," to implement your counter manually:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    let count = State::value(0);\n    let display = @H1 { text: "0" };\n\n    watch!(*$read(count)).subscribe(move |v| {\n      $write(display).text = v.to_string().into();\n    });\n\n    @Row {\n      @Button {\n        on_tap: move |_| *$write(count) += 1,\n        @ { "Increment" }\n      }\n      @{ display }\n    }\n  });\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Once we call ",(0,i.jsx)(n.code,{children:"subscribe"}),", we create a subscription to the expression in ",(0,i.jsx)(n.code,{children:"watch!"}),". This subscription will exist until you manually call ",(0,i.jsx)(n.code,{children:"unsubscribe"}),", or until the State that ",(0,i.jsx)(n.code,{children:"watch!"})," is listening to no longer has a write source."]}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, we don't need to call ",(0,i.jsx)(n.code,{children:"unsubscribe"})," because the subscription needs to exist throughout the application's lifecycle."]}),"\n",(0,i.jsxs)(n.p,{children:["Typically, there are two cases where you need to call ",(0,i.jsx)(n.code,{children:"unsubscribe"})," manually:"]}),"\n",(0,i.jsx)(n.p,{children:"In the first case, you want the subscription to have a shorter lifecycle than the state it is listening to. A typical example of this situation is building widgets using external state, for example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn show_name(name: State<String>) -> Widget<\'static> {\n  fn_widget!{\n    let mut text = @Text { text: "Hi, Guest!" };\n    let u = watch!($read(name).to_string()).subscribe(move |name| {\n      $write(text).text = format!("Hi, {}!", name).into();\n    });\n\n    // `name` is a shareable state that can be held by other people, \n    // making its lifecycle longer than that of the widget \n    // so we need to unsubscribe when the widget is destroyed.\n\n    @(text) { on_disposed: move |_| u.unsubscribe() }\n  }\n  .into_widget()\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In the second case, the downstream of ",(0,i.jsx)(n.code,{children:"watch!"})," performs a write operation on the listened state. Because ",(0,i.jsx)(n.code,{children:"watch!"})," relies on the listened state no longer having a write source to automatically unsubscribe, this constitutes a circular reference when its downstream holds a write source for the listened state. At this point, the subscription must be manually unsubscribed or a memory leak will result. Example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nlet even_num = State::value(0);\n\n// Respond to changes in even_num, ensure it is even. \n// If even_num is odd, add 1 to make it even\nlet u = watch!(*$read(even_num)).subscribe(move |v| {\n  if v % 2 == 1 {\n    *even_num.write() = v + 1;\n  }\n});\n\n// The following code needs to be called at the right time, otherwise it will result in circular references\nu.unsubscribe()\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"compose-widget---describing-your-data-structure",children:[(0,i.jsx)(n.code,{children:"Compose"})," widget - describing your data structure"]}),"\n",(0,i.jsxs)(n.p,{children:["Often, in complex real-world scenarios, you can't do it all by just creating some localized data and using simple function widgets. You need your own data structures, and you can map your data structures to views with the ",(0,i.jsx)(n.code,{children:"Compose"})," widget."]}),"\n",(0,i.jsxs)(n.p,{children:["Rewrite the counter example to use the ",(0,i.jsx)(n.code,{children:"Compose"})," widget:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use  ribir::prelude::*;\n\nstruct Counter(usize);\n\nimpl Counter {\n  fn increment(&mut self) {\n    self.0 += 1;\n  }\n}\n\nimpl Compose for Counter {\n  fn compose(this: impl StateWriter<Value = Self>) -> Widget<'static> {\n    button! {\n      on_tap: move |_| $write(this).increment(),\n      @pipe!($read(this).0.to_string())\n    }\n    .into_widget()\n  }\n}\n\nfn main() { \n  App::run(fn_widget!(Counter(0))); \n}\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, when you implement ",(0,i.jsx)(n.code,{children:"Compose"})," for ",(0,i.jsx)(n.code,{children:"Counter"}),", ",(0,i.jsx)(n.code,{children:"Counter"})," and all writable states of ",(0,i.jsx)(n.code,{children:"Counter"})," are now a legal widget."]}),"\n",(0,i.jsx)(n.h2,{id:"built-in-widgets",children:"Built-in widgets"}),"\n",(0,i.jsx)(n.p,{children:"Ribir provides a set of built-in widgets that allow you to configure the underlying styles, events, lifecycle, etc. The important difference between built-in widgets and regular widgets is that when you create a widget declaratively, you can use the fields and methods of the built-in widgets as if they were your own, and Ribir does the work of creating and compose the built-in widgets for you."}),"\n",(0,i.jsxs)(n.p,{children:["Let's take ",(0,i.jsx)(n.code,{children:"Margin"})," for example, suppose you want to set a margin of 10 pixels for a ",(0,i.jsx)(n.code,{children:"Text"}),", the code would look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // Declare `Margin` as the parent of `Text`\n    @Margin {\n      margin: EdgeInsets::all(10.),\n      @Text { text: "Hello World!" }\n    }\n  });\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["But you don't have to explicitly declare a ",(0,i.jsx)(n.code,{children:"Margin"}),", you can write it directly as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // Use the `Margin::margin` field directly in `Text`\n    @Text {\n      margin: EdgeInsets::all(10.),\n      text: "Hello World!"\n    }\n  });\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"When you create a widget declaratively, you can access the fields of the built-in widgets directly, even if you don't show them declared (if you use them in your code, the corresponding built-in widgets will be created). For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // `margin` is not declared\n    let mut hello_world = @Text { text: "Hello World!" };\n    // But you can still access the `margin` field,\n    // It\'s created with default value when you use it. \n    *$write(hello_world.margin()) = EdgeInsets::all(10.);\n    hello_world\n  });\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This is extended by the generic type ",(0,i.jsx)(n.code,{children:"FatObj"}),", refer to the API documentation for ",(0,i.jsx)(n.a,{href:"https://docs.rs/ribir_core/0.4.0-alpha.40/ribir_core/builtin_widgets/struct.FatObj.html",children:(0,i.jsx)(n.code,{children:"FatObj"})})," to see all the extensibility it provides."]}),"\n",(0,i.jsx)(n.h2,{id:"state-transitions-separation-and-traceability",children:"State Transitions, Separation, and Traceability"}),"\n",(0,i.jsx)(n.p,{children:"As you have learned after the previous chapters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"State modifications to data cause dependent views to be updated directly"}),"\n",(0,i.jsxs)(n.li,{children:["The mapping of data to views is accomplished through ",(0,i.jsx)(n.code,{children:"Compose"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Assuming that ",(0,i.jsx)(n.code,{children:"AppData"})," is the data for your entire application, you can map it to a view with ",(0,i.jsx)(n.code,{children:"Compose"}),". However, if ",(0,i.jsx)(n.code,{children:"AppData"})," is a complex piece of data, mapping the entire application view with a single ",(0,i.jsx)(n.code,{children:"Compose"})," would be a disaster in terms of code organization; and relying on a single state for the entire application view would result in any modification to ",(0,i.jsx)(n.code,{children:"AppData"})," updating the entire dynamic portion of the view, which in most cases would result in less than optimal interactive performance."]}),"\n",(0,i.jsx)(n.p,{children:"Luckily, Ribir provides a set of mechanisms for transforming, separating, and tracing state. It lets you start with a complete application state, then transform or separate the application state into smaller sub-states, which in turn can continue to transform or separate...; and within the sub-states you can transform or separate... ; and within the sub-states, you can access the source of your own transitions or separations through the traceability mechanism."}),"\n",(0,i.jsx)(n.h3,{id:"transitions-and-separation-converting-states-into-sub-states",children:"Transitions and Separation, converting states into sub-states"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Transitions"})," are the transitions from a parent state to a child state. The parent and child states share the same data, and modifying the parent state is equivalent to modifying the child state, and vice versa. It simply reduces the visible scope of the data, making it easier if you want to use and pass only part of the state.\n**Separation is the separation of child states from a parent state, where the parent and child states share the same data. The difference is that changing data in the child state does not trigger dependent view updates for the parent state."]}),"\n",(0,i.jsx)(n.p,{children:"You should note that the parent and child states share the same data regardless of whether they are transformed or separated. Therefore, their modifications to the data affect each other, but the scope of the data changes they push may be different."}),"\n",(0,i.jsx)(n.p,{children:"Carefully reading the following examples will help you better understand how state transitions and separations work:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nstruct AppData {\n  count: usize,\n}\n\nlet state = State::value(AppData { count: 0 });\nlet map_count = state.part_writer(PartialId::any(), |d| PartMut::new(&mut d.count));\nlet split_count = state.part_writer(PartialId::any(), |d| PartMut::new(&mut d.count));\n\nwatch!($read(state).count).subscribe(|_| println!("Parent data"));\nwatch!(*$read(map_count)).subscribe(|_| println!("Child(map) data"));\nwatch!(*$read(split_count)).subscribe(|_| println!("Child(split) data"));\nstate\n  .raw_modifies()\n  .filter(|s| s.contains(ModifyEffect::FRAMEWORK))\n  .subscribe(|_| println!("Parent framework"));\nmap_count\n  .raw_modifies()\n  .filter(|s| s.contains(ModifyEffect::FRAMEWORK))\n  .subscribe(|_| println!("Child(map) framework"));\nsplit_count\n  .raw_modifies()\n  .filter(|s| s.contains(ModifyEffect::FRAMEWORK))\n  .subscribe(|_| println!("Child(split) framework"));\n\n// Modify data through the split sub-state, the data modification push to both the parent and child state subscribers.\n// But only the split sub-state subscribers are pushed framework notifications.\n*split_count.write() = 1;\nAppCtx::run_until_stalled();\n// Print:\n// Parent data\n// Child(map) data\n// Child(split) data\n// Child(split) framework\n\n// When data is modified through the parent state, both the data modification and framework notifications are pushed to the subscribers of the parent and child states. However, the split sub-state becomes invalidated.\nstate.write().count = 3;\n// The push is asynchronous, forcing the push to be sent immediately\nAppCtx::run_until_stalled();\n// Print:\n// Parent data\n// Child(map) data\n// Parent framework\n// Child(map) framework\n\n// Modify data through the map sub-state, the data modification push to both the parent and child state subscribers.\n*map_count.write() = 2;\nAppCtx::run_until_stalled();\n// Print:\n// Parent data\n// Child(map) data\n// Parent framework\n// Child(map) framework\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Because Ribir's data modification notifications are sent out in asynchronous batches, we call ",(0,i.jsx)(n.code,{children:"AppCtx::run_until_stalled()"})," every time a data modification is made to force comprehensible sends in the example for ease of understanding, but this shouldn't be in your real code."]}),"\n",(0,i.jsxs)(n.p,{children:["If you just want a read-only sub-state, then you can convert it with ",(0,i.jsx)(n.code,{children:"part_reader"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"let count_reader = state.part_reader(|d| &d.count);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But Ribir doesn't provide a ",(0,i.jsx)(n.code,{children:"split_reader"}),", because separating a read-only sub-state is equivalent to converting a read-only sub-state."]}),"\n",(0,i.jsx)(n.h2,{id:"the-next-step",children:"The next step"}),"\n",(0,i.jsxs)(n.p,{children:["You have mastered all the syntax and basic concepts needed to develop a Ribir application. Now it's time to put them into practice with ",(0,i.jsx)(n.a,{href:"/docs/next/practice_todos_app/develop_a_todos_app",children:"Exercise: Todos application"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},4971:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/box_counter-d9866f46c0a2eaeda5ce7b6e6e0bcb2e.gif"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);