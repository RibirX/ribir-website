"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4255],{3769:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var t=i(4848),a=i(8453);const s={sidebar_position:2},o="Animations",r={id:"advanced/animations",title:"Animations",description:"Ribir provides a powerful animation system that allows you to create smooth, interactive UIs. The animation system is built around the @Animate widget and various transition mechanisms that enable you to animate any state in your application.",source:"@site/docs/advanced/animations.md",sourceDirName:"advanced",slug:"/advanced/animations",permalink:"/docs/next/advanced/animations",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1767062846e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Custom Widgets",permalink:"/docs/next/advanced/custom_widgets"},next:{title:'Using Ribir without relying on "DSL"',permalink:"/docs/next/advanced/without_dsl"}},d={},l=[{value:"Animate",id:"animate",level:2},{value:"Basic Animation",id:"basic-animation",level:3},{value:"Animation Lifecycle and Runtime Behavior",id:"animation-lifecycle-and-runtime-behavior",level:3},{value:"Auto-binding Animations",id:"auto-binding-animations",level:3},{value:"Advanced Animations",id:"advanced-animations",level:2},{value:"Keyframe Animations",id:"keyframe-animations",level:3},{value:"Complex Animations with Stagger",id:"complex-animations-with-stagger",level:3},{value:"Advanced Stagger Features",id:"advanced-stagger-features",level:4},{value:"Animation Control",id:"animation-control",level:3},{value:"Animation Composition",id:"animation-composition",level:3},{value:"Advanced Transition Modifiers",id:"advanced-transition-modifiers",level:3},{value:"Repeating and Delayed Animations",id:"repeating-and-delayed-animations",level:4}];function c(n){const e={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"animations",children:"Animations"}),"\n",(0,t.jsxs)(e.p,{children:["Ribir provides a powerful animation system that allows you to create smooth, interactive UIs. The animation system is built around the ",(0,t.jsx)(e.code,{children:"@Animate"})," widget and various transition mechanisms that enable you to animate any state in your application."]}),"\n",(0,t.jsx)(e.h2,{id:"animate",children:"Animate"}),"\n",(0,t.jsxs)(e.p,{children:["The primary way to create animations is through ",(0,t.jsx)(e.code,{children:"@Animate"}),", where you can specify the duration, easing function, and state changes."]}),"\n",(0,t.jsx)(e.h3,{id:"basic-animation",children:"Basic Animation"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"@Animate"})," requires three main properties:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"state"}),": The state you want to animate. It must implement the ",(0,t.jsx)(e.code,{children:"AnimateState"})," trait. Basic types ",(0,t.jsx)(e.code,{children:"impl StateWriter<T: Clone>"})," already implement it, so you just need to get the ",(0,t.jsx)(e.code,{children:"StateWriter"})," of the corresponding property."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"from"}),": The starting value of the animation."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"transition"}),": How the animation should progress over time."]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["Once the animation is created, simply call the ",(0,t.jsx)(e.code,{children:"run"})," method to start it."]}),"\n",(0,t.jsx)(e.p,{children:"Ribir has predefined some animation Transitions:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"easing::LINEAR"}),": Animates at a constant speed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"easing::EASE_IN"}),": Starts slowly, accelerates toward the end"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"easing::EASE_OUT"}),": Starts quickly, decelerates toward the end"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"easing::EASE_IN_OUT"}),": Starts slowly, accelerates in the middle, then decelerates"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"easing::CubicBezierEasing"}),": Cubic Bezier easing"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["In the following example, ",(0,t.jsx)(e.code,{children:"SizedBox"})," will perform a bouncing animation when first loaded."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn custom_easing_example() -> Widget<'static> {\n    fn_widget! {\n        let mut moving_box = @SizedBox {\n            size: Size::new(50., 50.),\n            background: Color::RED,\n            margin: EdgeInsets::horizontal(200.),\n        };\n\n        let animate = @Animate {\n            state: moving_box.margin(),\n            from: EdgeInsets::horizontal(0.),\n            transition: EasingTransition {\n                duration: Duration::from_millis(1000),\n                easing: easing::CubicBezierEasing::new(0.68, -0.55, 0.265, 1.55), // Bounce effect\n            }\n        };\n\n        @SizedBox {\n            size: Size::new(250., 100.),\n            @(moving_box) {  \n                on_mounted: move |_| animate.run(),\n            }\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"animation-lifecycle-and-runtime-behavior",children:"Animation Lifecycle and Runtime Behavior"}),"\n",(0,t.jsx)(e.p,{children:"Understanding the animation lifecycle is crucial for effective animation implementation. The Ribir animation system follows specific patterns for how animations interact with state and the rendering pipeline:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Each frame draw"}),": During rendering, the animation modifies state values to reflect the current progress of the animation. On each frame, the animation system calculates the interpolated value based on the current time and transition function, and temporarily updates the state with that value."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"End of drawing"}),": After the frame is rendered, the animation system restores the original state values. This ensures that the underlying data model remains unchanged once the animation completes."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"State propagation"}),": During animation, the state changes are modified through the ",(0,t.jsx)(e.code,{children:"shallow()"})," method of the ",(0,t.jsx)(e.code,{children:"StateWriter"})," in the reactive system. This method updates the state and notifies the widget system for efficient repainting, but it ",(0,t.jsx)(e.strong,{children:"does not"})," trigger a full reactive notification for all listeners (like those in ",(0,t.jsx)(e.code,{children:"pipe!"})," blocks) to avoid performance overhead and potential infinite loops."]}),"\n",(0,t.jsxs)(e.p,{children:["This is why it is critical to bind ",(0,t.jsx)(e.code,{children:"Animate"})," directly to the ",(0,t.jsx)(e.strong,{children:"Widget property's Writer"})," (e.g. ",(0,t.jsx)(e.code,{children:"widget.map_writer(...)"}),") rather than a standalone ",(0,t.jsx)(e.code,{children:"Stateful"})," variable. When bound to a widget property's Writer, the ",(0,t.jsx)(e.code,{children:"shallow()"})," update correctly notifies the widget to redraw with the new interpolated value, while other data bound to that state will not receive update notifications."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This behavior ensures that:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Animations run smoothly at high frame rates"}),"\n",(0,t.jsx)(e.li,{children:"State changes during animation don't cause UI reflows or unnecessary rebuilds"}),"\n",(0,t.jsx)(e.li,{children:"The original state value is preserved after animation completion"}),"\n",(0,t.jsx)(e.li,{children:"Animation performance is optimized by avoiding redundant reactive updates"}),"\n",(0,t.jsx)(e.li,{children:"Animations run smoothly at high frame rates"}),"\n",(0,t.jsx)(e.li,{children:"State changes during animation don't cause UI reflows or unnecessary rebuilds"}),"\n",(0,t.jsx)(e.li,{children:"Interpolated state values are applied only while each animation frame is being rendered; after the frame is drawn the original state is restored, so these interpolated changes do not persist beyond the animation's drawing step"}),"\n",(0,t.jsx)(e.li,{children:"Animation performance is optimized by avoiding redundant reactive updates"}),"\n"]}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Important"}),": Bind the animation to the Widget's state (e.g., using ",(0,t.jsx)(e.code,{children:"map_writer"})," or property writers like ",(0,t.jsx)(e.code,{children:".opacity()"}),"). Because ",(0,t.jsx)(e.code,{children:"Animate"})," uses ",(0,t.jsx)(e.code,{children:"shallow()"})," updates, these updates will not trigger linked updates."]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["A common mistake is to create a standalone ",(0,t.jsx)(e.code,{children:"Stateful"})," variable, animate it, and bind it to a widget using ",(0,t.jsx)(e.code,{children:"pipe!"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"ignore",children:"// \u274c WRONG: Do not animate intermediate state\nfn_widget! {\n    let opacity_state = Stateful::new(0.0);\n    let animate = @Animate {\n        state: opacity_state.clone_writer(),\n        ...\n    };\n\n    @SizedBox {\n        opacity: pipe!(*$read(opacity_state)),\n        on_tap: move |_| animate.run(),\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["This fails because the value of ",(0,t.jsx)(e.code,{children:"opacity_state"})," is modified during the animation process, but it does not propagate, so ",(0,t.jsx)(e.code,{children:"pipe!"})," will not perceive it and trigger an update."]}),"\n",(0,t.jsx)(e.p,{children:"The correct approach is to bind the animation directly to the Widget's state, as follows:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"ignore",children:"// \u2705 CORRECT: Animate Widget's state\nfn_widget! {\n    let w = @SizedBox {\n        opacity: 1.,\n        ...\n    };\n    let animate = @Animate {\n        state: w.opacity(),\n        ...\n    };\n\n    @(w) { on_tap: move |_| animate.run() }\n}\n\n"})}),"\n",(0,t.jsx)(e.h3,{id:"auto-binding-animations",children:"Auto-binding Animations"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Animate"})," provides the most basic capabilities, allowing you to manually control the start and stop of animations. In addition to this, Ribir also provides a convenient way to bind animations to the property itself, automatically triggering the transition animation when the property value changes."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\nuse ribir::material::md;\nfn writer_animate() -> Widget<'static> {\n    fn_widget! {\n        let mut w = @Container { size: Size::new(40., 20.) };\n        w.opacity()\n            .transition(EasingTransition{\n                easing: md::easing::STANDARD_ACCELERATE,\n                duration: md::easing::duration::SHORT2\n            });\n\n        let cnt = Stateful::new(0);\n\n        @(w) {\n            on_tap: move |_| {\n                *$write(cnt) += 1;\n                if (*$read(cnt) % 2 == 0) {\n                    *$write(w.opacity()) = 1.;\n                } else {\n                    *$write(w.opacity()) = 0.5;\n                }\n            },\n            background: Color::RED,\n        }\n\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Here, the ",(0,t.jsx)(e.code,{children:"StateWriter"})," returned by ",(0,t.jsx)(e.code,{children:"w.opacity()"})," implements the ",(0,t.jsx)(e.code,{children:"AnimateState"})," trait. By setting the animation property through the ",(0,t.jsx)(e.code,{children:"transition()"})," method, the animation is automatically triggered when the value is modified via the ",(0,t.jsx)(e.code,{children:"StateWriter"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"advanced-animations",children:"Advanced Animations"}),"\n",(0,t.jsx)(e.h3,{id:"keyframe-animations",children:"Keyframe Animations"}),"\n",(0,t.jsx)(e.p,{children:"Keyframes allow you to specify intermediate steps in an animation, providing fine-grained control over complex animations."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn keyframes_example() -> Widget<'static> {\n    fn_widget! {\n        let mut box_widget = @SizedBox {\n            size: Size::new(50., 50.),\n            background: Color::GREEN,\n        };\n\n        let animate = @Animate {\n            state: keyframes! {\n                state: box_widget.map_writer(|w| PartMut::new(&mut w.size)),\n                0.25 => Size::new(100., 50.),  // Stretch horizontally at 25% progress\n                0.5 => Size::new(100., 100.),  // Stretch vertically at 50% progress\n                0.75 => Size::new(50., 100.),  // Shrink horizontally at 75% progress\n                1.0 => Size::new(50., 50.),    // Return to original at 100% progress\n            },\n            from: Size::new(50., 50.),\n            transition: EasingTransition {\n                duration: Duration::from_millis(1000),\n                easing: easing::EASE_IN_OUT,\n            }\n        };\n\n        @(box_widget) { \n            on_tap: move |_| animate.run(),\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"Keyframes can be defined using either decimal values (0.0 to 1.0) or percentages:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"ignore",children:"// Using percentage syntax\nlet keyframe_state = keyframes! {\n    state: opacity_writer,\n    20% => 0.2,\n    50% => 0.5,\n    80% => 0.8,\n};\n"})}),"\n",(0,t.jsx)(e.h3,{id:"complex-animations-with-stagger",children:"Complex Animations with Stagger"}),"\n",(0,t.jsxs)(e.p,{children:["For coordinating multiple animations, Ribir provides the ",(0,t.jsx)(e.code,{children:"Stagger"})," animation controller. This allows you to create sequences where animations start at timed intervals, creating sophisticated visual effects:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn stagger_example() -> Widget<\'static> {\n    fn_widget! {\n        let stagger = Stagger::new(\n            Duration::from_millis(200), // 200ms between each animation start\n            EasingTransition {\n                duration: Duration::from_millis(500),\n                easing: easing::EASE_IN_OUT,\n            },\n        );\n\n        let mut text1 = @Text { text: "One", opacity: 0. };\n        let mut text2 = @Text { text: "Two", opacity: 0. };\n        let mut text3 = @Text { text: "Three", opacity: 0. };\n\n        // Add animations to the stagger\n        stagger.write().push_state(text1.opacity(), 0.);\n        stagger.write().push_state(text2.opacity(), 0.);\n        stagger.write().push_state(text3.opacity(), 0.);\n\n        @Column {\n            on_mounted: move |_| stagger.run(),\n            @{ [text1, text2, text3] }\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"advanced-stagger-features",children:"Advanced Stagger Features"}),"\n",(0,t.jsx)(e.p,{children:"Stagger animations provide additional control options:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Different staggers"}),": Use ",(0,t.jsx)(e.code,{children:"push_animation_with()"})," to specify different time intervals for each animation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Mixed animations"}),": Combine state-based animations with complete ",(0,t.jsx)(e.code,{children:"@Animate"})," widgets in the same sequence"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Runtime control"}),": Access stagger status using methods like ",(0,t.jsx)(e.code,{children:"is_running()"}),", ",(0,t.jsx)(e.code,{children:"run_times()"}),", and ",(0,t.jsx)(e.code,{children:"has_ever_run()"})]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn advanced_stagger_example() -> Widget<'static> {\n    fn_widget! {\n        let stagger = Stagger::new(\n            Duration::from_millis(100),\n            EasingTransition {\n                duration: Duration::from_millis(300),\n                easing: easing::EASE_IN_OUT,\n            }\n        );\n\n        let mut box1 = @SizedBox { size: Size::new(50., 50.), background: Color::RED, opacity: 0. };\n        let mut box2 = @SizedBox { size: Size::new(50., 50.), background: Color::GREEN, opacity: 0. };\n        let mut box3 = @SizedBox { size: Size::new(50., 50.), background: Color::BLUE, opacity: 0. };\n\n        // Add boxes with different stagger intervals\n        stagger.write().push_state(box1.opacity(), 0.);\n        stagger.write().push_state_with(Duration::from_millis(200), box2.opacity(), 0.); // Wait 200ms\n        stagger.write().push_animation({\n            let animate = @Animate {\n                state: box3.opacity(),\n                from: 0.,\n                transition: EasingTransition {\n                    duration: Duration::from_millis(300),\n                    easing: easing::EASE_IN_OUT,\n                }\n            };\n            animate\n        });\n\n        @Row {\n            on_mounted: move |_| stagger.run(),\n            @{ [box1, box2, box3] }\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"animation-control",children:"Animation Control"}),"\n",(0,t.jsx)(e.p,{children:"Animations can be controlled programmatically using the animation instance:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"run()"}),": Starts or restarts the animation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"stop()"}),": Stops the animation and restores the state to its final value"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"is_running()"}),": Checks if the animation is currently running"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn animation_control_example() -> Widget<\'static> {\n    fn_widget! {\n        let mut box_widget = @SizedBox {\n            size: Size::new(100., 100.),\n            background: Color::PURPLE,\n            opacity: 0.0,\n        };\n\n        let tap_animation = @Animate {\n            state: box_widget.opacity(),\n            from: 0.,\n            transition: EasingTransition {\n                duration: Duration::from_millis(2000),\n                easing: easing::EASE_IN_OUT,\n            }\n        };\n\n        let animation = @Animate {\n            state: box_widget.opacity(),\n            from: 0.,  // Start from current value is done dynamically\n            transition: EasingTransition {\n                duration: Duration::from_millis(2000),\n                easing: easing::EASE_IN_OUT,\n            }\n        };\n\n        @Column {\n            @Row {\n                @Button {\n                    on_tap: move |_| {\n                        let val = *$read(box_widget.opacity());\n                        *$write(box_widget.opacity()) = 1.0 - val;\n                        // the on_tap handler will take the ownership of animation, here use the $writer to auto clone\n                        $writer(animation).run(); \n                    },\n                    @Text { text: "Start" }\n                }\n                @Button {\n                    on_tap: move |_| {\n                        animation.stop();\n                    },\n                    @Text { text: "Stop" }\n                }\n            }\n            @ { box_widget }\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"animation-composition",children:"Animation Composition"}),"\n",(0,t.jsx)(e.p,{children:"Animations can be combined and layered to create complex effects. You can:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Run multiple animations in parallel using different state values"}),"\n",(0,t.jsx)(e.li,{children:"Modify multiple properties in a single animation"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn composition_example() -> Widget<'static> {\n    fn_widget! {\n        let mut box_widget = @SizedBox {\n            size: Size::new(50., 50.),\n            background: Color::BLUE,\n            opacity: 0.,\n            transform: Transform::identity(),\n        };\n\n        let opacity_size_anim = @Animate {\n            state: (box_widget.opacity(), box_widget.map_writer(|w| PartMut::new(&mut w.size))),\n            from: (0., Size::new(50., 50.)),\n            transition: EasingTransition {\n                duration: Duration::from_millis(1000),\n                easing: easing::EASE_IN_OUT,\n            }\n        };\n\n        let rotation_anim = @Animate {\n            state: box_widget.transform(),\n            from: Transform::identity(),\n            transition: EasingTransition {\n                duration: Duration::from_millis(2000),\n                easing: easing::LINEAR,\n            }\n        };\n\n        @(box_widget) {\n            on_tap: move |_| {\n                opacity_size_anim.run();\n                rotation_anim.run();\n            },\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"advanced-transition-modifiers",children:"Advanced Transition Modifiers"}),"\n",(0,t.jsxs)(e.p,{children:["Animations can be enhanced using various transition modifiers that provide additional functionality. Two common modifiers are ",(0,t.jsx)(e.code,{children:"repeat"})," and ",(0,t.jsx)(e.code,{children:"delay"}),"."]}),"\n",(0,t.jsx)(e.h4,{id:"repeating-and-delayed-animations",children:"Repeating and Delayed Animations"}),"\n",(0,t.jsxs)(e.p,{children:["Animations can combine the ",(0,t.jsx)(e.code,{children:"repeat"})," and ",(0,t.jsx)(e.code,{children:"delay"})," transition modifiers. The following example shows an animation that waits 1000ms before starting, then repeats three times, blinking by animating opacity from 0 to 1."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn transition_modifiers_example() -> Widget<'static> {\n    fn_widget! {\n        let mut box_widget = @SizedBox {\n            size: Size::new(200., 100.),\n            background: Color::YELLOW,\n            opacity: 1.,\n        };\n\n        let animate = @Animate {\n            state: box_widget.opacity(),\n            from: 0.,\n            transition: EasingTransition {\n                duration: Duration::from_millis(100),\n                easing: easing::steps(2, easing::StepsJump::JumpNone),\n            }\n            .repeat(3.) // Then repeat 3 times\n            .delay(Duration::from_millis(1000)) // Wait 1000ms before starting\n        };\n\n        @(box_widget) {\n            on_mounted: move |_| animate.run(), // Start the animation after delay with repetitions\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"Animations are a powerful tool for creating engaging, intuitive user experiences. By mastering the animation system in Ribir, you can create smooth, responsive applications that feel alive and interactive."})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>r});var t=i(6540);const a={},s=t.createContext(a);function o(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);