"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6618],{8520:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>a});var i=n(4848),s=n(8453);const o={sidebar_position:1},r="Declarative UI",d={id:"concepts/declarative_ui",title:"Declarative UI",description:"Ribir uses a declarative DSL (Domain Specific Language) based on Rust macros to define the user interface. This allows you to describe what the UI should look like, rather than how to construct it step-by-step.",source:"@site/docs/concepts/declarative_ui.md",sourceDirName:"concepts",slug:"/concepts/declarative_ui",permalink:"/docs/next/concepts/declarative_ui",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1770794042e3,sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Core Concepts",permalink:"/docs/next/category/core-concepts"},next:{title:"Widget System",permalink:"/docs/next/concepts/widgets_composition"}},c={},a=[{value:"The <code>fn_widget!</code> Macro",id:"the-fn_widget-macro",level:2},{value:"Creating Widgets with <code>@</code>",id:"creating-widgets-with-",level:2},{value:"Parent-Child Composition",id:"parent-child-composition",level:2},{value:"Reusing Widgets (Static Composition)",id:"reusing-widgets-static-composition",level:2},{value:"Dynamic Widgets",id:"dynamic-widgets",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"declarative-ui",children:"Declarative UI"}),"\n",(0,i.jsxs)(t.p,{children:["Ribir uses a declarative DSL (Domain Specific Language) based on Rust macros to define the user interface. This allows you to describe ",(0,i.jsx)(t.em,{children:"what"})," the UI should look like, rather than ",(0,i.jsx)(t.em,{children:"how"})," to construct it step-by-step."]}),"\n",(0,i.jsxs)(t.p,{children:["The core of this DSL is the ",(0,i.jsx)(t.code,{children:"fn_widget!"})," macro."]}),"\n",(0,i.jsxs)(t.h2,{id:"the-fn_widget-macro",children:["The ",(0,i.jsx)(t.code,{children:"fn_widget!"})," Macro"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"fn_widget!"})," is the entry point for writing Ribir UI code. It transforms the DSL syntax into actual Rust code that builds the widget tree."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn main() {\n    App::run(fn_widget! {\n        @Text { text: "Hello!" }\n    });\n}\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"creating-widgets-with-",children:["Creating Widgets with ",(0,i.jsx)(t.code,{children:"@"})]}),"\n",(0,i.jsxs)(t.p,{children:["To instantiate a widget, use the ",(0,i.jsx)(t.code,{children:"@"})," symbol followed by the widget struct name. Properties are defined inside the curly braces ",(0,i.jsx)(t.code,{children:"{}"})," using standard Rust struct initialization syntax ",(0,i.jsx)(t.code,{children:"key: value"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["When ",(0,i.jsx)(t.code,{children:"@"})," is followed directly by a type, it invokes the corresponding builder to construct the object. This builder is typically generated by the ",(0,i.jsx)(t.code,{children:"#[declare]"})," macro, which enables the use of built-in attributes. We will explore this mechanism in detail in the ",(0,i.jsx)(t.a,{href:"/docs/next/concepts/built_in_attributes_and_fat_obj",children:"Built-in Attributes & FatObj"})," section."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Important"}),": The ",(0,i.jsx)(t.code,{children:"@"})," operator is ",(0,i.jsx)(t.strong,{children:"DSL-specific"})," and only works within macros that support the Ribir DSL syntax, such as ",(0,i.jsx)(t.code,{children:"fn_widget!"})," and ",(0,i.jsx)(t.code,{children:"rdl!"}),". This operator is not valid Rust syntax outside of these macros and will cause compilation errors if used in regular Rust code or nested within third-party macros."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn example() -> Widget<\'static> {\n    fn_widget! {\n        @Text { text: "I am a Text widget" }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"parent-child-composition",children:"Parent-Child Composition"}),"\n",(0,i.jsx)(t.p,{children:"Ribir represents the UI as a tree. You can compose widgets by nesting them. Widgets that support children allow you to declare them directly inside their block."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn composition_example() -> Widget<\'static> {\n    fn_widget! {\n        @Column {\n            @Text { text: "Item 1" }\n            @Text { text: "Item 2" }\n            @Button {\n                @ { "Click Me" }\n            }\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Here ",(0,i.jsx)(t.code,{children:"Column"})," is a widget that supports multiple children (",(0,i.jsx)(t.code,{children:"MultiChild"}),", see ",(0,i.jsx)(t.a,{href:"/docs/next/concepts/widgets_composition",children:"Widget Composition"}),"), which allows you to declare children directly inside its block.\n",(0,i.jsx)(t.code,{children:"Button"})," is a widget that supports template children (",(0,i.jsx)(t.code,{children:"TemplateChild"}),", see ",(0,i.jsx)(t.a,{href:"/docs/next/concepts/widgets_composition",children:"Widget Composition"}),"). It automatically sets the corresponding properties through type matching, so you use ",(0,i.jsx)(t.code,{children:'@ { "Click Me" }'})," to set the text, without needing ",(0,i.jsx)(t.code,{children:'text: "Click Me"'}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"reusing-widgets-static-composition",children:"Reusing Widgets (Static Composition)"}),"\n",(0,i.jsxs)(t.p,{children:["when you have a ",(0,i.jsx)(t.code,{children:"Widget"})," expression , you can assign it to a variable or return it from a function, and then use it inside another ",(0,i.jsx)(t.code,{children:"fn_widget!"})," block. This promotes reusability."]}),"\n",(0,i.jsxs)(t.p,{children:["To embed a widget variable or expression into the DSL, use the ",(0,i.jsx)(t.code,{children:"@ { expression }"})," syntax."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn header() -> Widget<\'static> {\n    fn_widget! {\n        @Text { text: "My App Header" }\n    }.into_widget()\n}\n\nfn app() -> Widget<\'static> {\n    let footer = fn_widget! {\n        @Text { text: "Footer Content" }\n    };\n\n    fn_widget! {\n        @Column {\n            @ header() // Embedding a function that returns a Widget\n            @Text { text: "title" }\n            @fn_widget!{ @Text { text: "Main Content" } }\n            @ { footer }   // Embedding a Widget variable\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note:"})," ",(0,i.jsx)(t.code,{children:"fn_widget"})," is like its name\u2014a function that returns a widget. Although it can be treated as a ",(0,i.jsx)(t.code,{children:"Widget"}),", it's a function ",(0,i.jsx)(t.code,{children:"fn -> FatObj<Stateful<Text>>"}),", which will be called depending on the framework's build process. Thus, ",(0,i.jsx)(t.code,{children:'@fn_widget!{ @Text { text: "Main Content" } }'})," differs from ",(0,i.jsx)(t.code,{children:'@Text { text: "title" }'}),", which is a ",(0,i.jsx)(t.code,{children:"FatObj<Stateful<Text>>"}),". With ",(0,i.jsx)(t.code,{children:'let text = @Text { text: "title" }'}),", we can access the Text's struct attributes, such as ",(0,i.jsx)(t.code,{children:"$read(text).text"}),", but this is not possible with ",(0,i.jsx)(t.code,{children:'@fn_widget!{ @Text { text: "Main Content" } }'}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"dynamic-widgets",children:"Dynamic Widgets"}),"\n",(0,i.jsxs)(t.p,{children:["Ribir allows you to create widgets that automatically update when their data changes. The ",(0,i.jsx)(t.code,{children:"pipe!"})," macro is the key tool for this. It creates a stream of values that can be transformed into widgets."]}),"\n",(0,i.jsxs)(t.p,{children:["To create a dynamic widget, you can use the ",(0,i.jsx)(t.code,{children:"pipe!"})," macro and embed it into your UI using the ",(0,i.jsx)(t.code,{children:"@ { ... }"})," syntax."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn dynamic_widget_example() -> Widget<\'static> {\n    let count = Stateful::new(0);\n\n    fn_widget! {\n        @Column {\n            @{\n                pipe!(*$read(count)).map(move |c| {\n                    if c % 2 == 0 {\n                        @H1 { text: "Even" }.into_widget()\n                    } else {\n                        @H2 { text: "Odd" }.into_widget()\n                    }\n                })\n            }\n            @Button {\n                on_tap: move |_| *$write(count) += 1,\n                @{ "Increment" }\n            }\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Here are two points to note:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"pipe!"})," pipeline returns different types of widgets based on conditions, so ",(0,i.jsx)(t.code,{children:".into_widget()"})," is used to unify them into a single ",(0,i.jsx)(t.code,{children:"Widget"})," type."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pipe!"})," monitors the state variables used in the expression (like ",(0,i.jsx)(t.code,{children:"$read(count)"}),"). When they change, the expression is re-evaluated, and the widget is updated."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The example uses ",(0,i.jsx)(t.code,{children:".map()"})," to transform the monitored result and build the corresponding Widget.\nHowever, Ribir also supports putting all operations inside ",(0,i.jsx)(t.code,{children:"pipe!"}),", as shown below:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:'@ {\n    pipe! {\n        if *$read(count) % 2 == 0 {\n            @Text { text: "Even" }.into_widget()\n        } else {\n            @Button { @Text { text: "Odd" } }.into_widget()\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Ribir automatically analyzes and listens for State changes in ",(0,i.jsx)(t.code,{children:"pipe!(expr)"})," and re-evaluates ",(0,i.jsx)(t.code,{children:"expr"})," when changes occur. However, ",(0,i.jsx)(t.code,{children:"pipe!($read(state)).map(expr)"})," can explicitly specify the State to listen to, which may offer better performance in complex scenarios."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>d});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);