"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/ribir_v0.1.0","metadata":{"permalink":"/blog/ribir_v0.1.0","source":"@site/blog/ribir_v0.1.0.md","title":"Ribir v0.1.0","description":"After several years of conception, especially the hard work of the past year, we are proud to announce that Ribir v0.1.0 is finally released.","date":"2024-04-09T02:50:21.000Z","formattedDate":"April 9, 2024","tags":[],"readingTime":2.925,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"nextItem":{"title":"Announcing Ribir v0.2.0","permalink":"/blog/ribir_v0.2.0"}},"content":"![](/landing-page/hero-banner.png)\\n\\nAfter several years of conception, especially the hard work of the past year, we are proud to announce that Ribir v0.1.0 is finally released. \\n\\n\\n## What is Ribir?\\n\\nRibir is an open-source Rust GUI framework that helps you build beautiful and native multi-platform applications from a single codebase.\\n\\nThe architecture overview of Ribir:\\n\\n![](/img/architecture.svg)\\n\\n## Build your UI non-intrusive\\n\\nThe most important goal of Ribir is to let you build your UI directly based on your data structure APIs. Any data mutation will trigger a precise UI update. Your focus should be on designing your data structure and its APIs. Then, you can describe your data\'s UI without intruding on its logic.\\n\\nYou can abstract your App data structure first and then describe your UI based on its APIs. This process does not necessitate any pre-design of the data structure.\\n\\n- No additional states\\n- No additional notification mechanisms \\n- No inheritance of any base classes\\n- No other pre-constraints. \\n\\n## Why Rust?\\n\\nBuilding a high-performance cross-platform framework that compiles natively, we had two options within our purview: C++ and Rust.\\n\\nInitially, we were more inclined to choose C++, because C++ has a more mature ecosystem, and we have years of experience in developing large tools based on C++. Although we have been learning and writing Rust for many years, to be honest, we have not used it extensively in a production project. Ultimately, the two core reasons that led us to choose Rust are:\\n\\n- The `trait`: Using Rust traits to implement our non-intrusive design feels so natural.\\n- Procedure macro: Using Rust\'s procedural macros for our DSL implementation eliminates the need for extra tools. When combined with Rust\'s toolchain, it offers an out-of-the-box solution, enhancing the overall development experience.\\n\\n## What is the current status of Ribir?\\n\\nThe goal of the first version of Ribir is to finish the core framework and answer our questions about the feasibility of the design.\\n\\nWe use it to build examples and build some apps for our daily work. And we are satisfied with the experience of using it.\\n\\nAlthough we implemented almost all the core features in the first version of Ribir. That seems you can use it to do many things. You need to know that it is still in a very early stage:\\n\\n- We only test and use it in a very limited environment \\n- There exist several known issues, including memory leaks and performance-related concerns, that are still awaiting resolution.\\n- Many APIs may break in the next version\\n\\nSo, we are very happy to share it with you. We hope you can try it out and give us feedback. But we don\'t recommend you to use it in production environments yet.\\n\\n## The next step\\n\\nAfter the first version of Ribir, it\'s time to turn us to a more practical direction. We are confident that we will iterate quickly and stable more features that the production environment needs.\\n\\nThe next version of Ribir will focus on the following things:\\n\\n- Enable WebAssembly support, so we can build web apps and share demos online.\\n- Introduce a stable and user-friendly overlay system to elegantly handle tooltips, popups, and other overlay UI elements.\\n- Stabilize the APIs of BuiltinObj and state, allowing for automatic cycle-reference breaking and memory leak prevention in most scenarios, and providing a reliable option for state unsubscribing.\\n\\n## Changelog\\n\\nThe detailed changelog is available in the [CHANGELOG.md](https://github.com/RibirX/Ribir/blob/master/CHANGELOG.md)\\n\\n\\n## Feedback\\n\\nWelcome to feedback and star our repo on [GitHub](https://github.com/RibirX/Ribir)"},{"id":"/ribir_v0.2.0","metadata":{"permalink":"/blog/ribir_v0.2.0","source":"@site/blog/ribir_v0.2.0.md","title":"Announcing Ribir v0.2.0","description":"We\'re excited to announce the completion of Ribir v0.2.0\'s development and the release of its first beta version. This release introduces two significant features: overlay support and the ability to use Ribir without \\"DSL\\".","date":"2024-04-09T02:50:21.000Z","formattedDate":"April 9, 2024","tags":[],"readingTime":1.525,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Ribir v0.1.0","permalink":"/blog/ribir_v0.1.0"}},"content":"We\'re excited to announce the completion of Ribir v0.2.0\'s development and the release of its first beta version. This release introduces two significant features: overlay support and the ability to use Ribir without \\"DSL\\".\\n\\n## Overlay Support\\n\\nThis feature simplifies the process of creating overlay widgets. It streamlines the addition of any widget to an overlay and provides a more user-friendly API for managing overlays.\\n\\nYou can use any widget to create an overlay, which will then appear on top of the current screen.\\n\\n```rust\\nuse ribir::prelude::*;\\n\\nfn main() {\\n  let overlay = Overlay::new(fn_widget! {\\n    @Text {\\n      h_align: HAlign::Center,\\n      v_align: VAlign::Center,\\n      text: \\"Hello\\"\\n    }\\n  });\\n  \\n  let w = fn_widget! {\\n    @FilledButton{\\n      on_tap: move |e| overlay.show(e.window()),\\n      @{ Label::new(\\"Click to show overlay\\") }\\n    }\\n  };\\n  \\n  App::run(w);\\n}\\n```\\n\\nRefer to its APIs to learn about all the features it offers.\\n\\n## Ribir without \\"DSL\\"\\n\\nWhile macros aren\'t a necessary part of using Ribir, our initial version didn\'t provide documentation or user-friendly APIs for building the UI without them. This release addresses that issue by providing a more straightforward API for building widgets without macros.\\n\\nWith macros:\\n\\n```rust\\nuse ribir::prelude::*;\\nfn main() {\\n  let counter = fn_widget! {\\n    let cnt = Stateful::new(0);\\n    @Row {\\n      @FilledButton {\\n        on_tap: move |_| *$cnt.write() += 1,\\n        @{ Label::new(\\"Inc\\") }\\n      }\\n      @H1 { text: pipe!($cnt.to_string()) }\\n    }\\n  };\\n  App::run(counter);\\n}\\n```\\n\\nWithout macros:\\n\\n```rust \\nuse ribir::prelude::*;\\n\\nfn main() {\\n  let counter = |ctx: &BuildCtx| {\\n    let cnt = Stateful::new(0);\\n\\n    let c_cnt = cnt.clone_writer();\\n    let inc_btn = FilledButton::declarer()\\n      .on_tap(move |_| *c_cnt.write() += 1)\\n      .finish(ctx)\\n      .with_child(Label::new(\\"Inc\\"), ctx);\\n\\n    let counter = H1::declarer()\\n      .text(pipe!($cnt.to_string()))\\n      .finish(ctx);\\n\\n    Row::declarer()\\n      .finish(ctx)\\n      .with_child(inc_btn, ctx)\\n      .with_child(counter, ctx)\\n      .build(ctx)\\n  };\\n\\n  App::run(counter);\\n}\\n\\n```\\n\\n\\nIn this version, we\'ve refined the APIs and updated the [guide](https://ribir.org/docs/understanding_ribir/without_dsl) to demonstrate how to use Ribir without the \\"DSL\\" feature.\\n\\n\\n## Additional Changes\\n\\nVisit the [Ribir](https://github.com/RibirX/Ribir/releases/tag/ribir-v0.2.0-beta.1) page for more details."}]}')}}]);