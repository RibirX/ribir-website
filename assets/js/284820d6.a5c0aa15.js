"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6921],{6799:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>o});var i=n(4848),s=n(8453);const r={},a="State Management",d={id:"guide/core_concepts/state_management",title:"State Management",description:"Ribir uses a data-driven approach to state management. Instead of manually updating widgets, you modify the data (state), and Ribir automatically updates the parts of the UI that depend on that data.",source:"@site/docs/guide/core_concepts/state_management.md",sourceDirName:"guide/core_concepts",slug:"/guide/core_concepts/state_management",permalink:"/docs/next/guide/core_concepts/state_management",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1766826148e3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Layout System",permalink:"/docs/next/guide/core_concepts/layout"},next:{title:"Widget System",permalink:"/docs/next/guide/core_concepts/widgets_composition"}},c={},o=[{value:"Stateful Objects",id:"stateful-objects",level:2},{value:"StateReader<T>",id:"statereader",level:3},{value:"StateWatcher<T>",id:"statewatcher",level:3},{value:"StateWriter<T>",id:"statewriter",level:3},{value:"Reading and Writing State",id:"reading-and-writing-state",level:2},{value:"DSL Operators in Third-Party Macros",id:"dsl-operators-in-third-party-macros",level:2},{value:"Simplified State Access in <code>fn_widget!</code> Closures",id:"simplified-state-access-in-fn_widget-closures",level:2},{value:"Reactive Binding with <code>pipe!</code>",id:"reactive-binding-with-pipe",level:2},{value:"Important: Avoid Using <code>BuildCtx</code> Inside <code>pipe!</code> Expressions",id:"important-avoid-using-buildctx-inside-pipe-expressions",level:3},{value:"Reacting to Changes with <code>watch!</code>",id:"reacting-to-changes-with-watch",level:2},{value:"<code>pipe!</code> vs <code>watch!</code>",id:"pipe-vs-watch",level:3},{value:"Advanced: Mapped &amp; Distinct Pipes",id:"advanced-mapped--distinct-pipes",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",t:"t",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"state-management",children:"State Management"}),"\n",(0,i.jsx)(t.p,{children:"Ribir uses a data-driven approach to state management. Instead of manually updating widgets, you modify the data (state), and Ribir automatically updates the parts of the UI that depend on that data."}),"\n",(0,i.jsx)(t.h2,{id:"stateful-objects",children:"Stateful Objects"}),"\n",(0,i.jsxs)(t.p,{children:["The core primitive for state in Ribir is ",(0,i.jsx)(t.code,{children:"Stateful<T>"}),". It wraps a piece of data ",(0,i.jsx)(t.code,{children:"T"})," and makes it observable. When the data inside a ",(0,i.jsx)(t.code,{children:"Stateful"})," object is modified, Ribir notifies all observers (widgets, pipes, watchers) that the state has changed."]}),"\n",(0,i.jsxs)(t.p,{children:["To create a stateful object, use ",(0,i.jsx)(t.code,{children:"Stateful::new(value)"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nfn main() {\n    let count = Stateful::new(0);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Stateful<T>"})," actually implements ",(0,i.jsx)(t.code,{children:"StateReader<T>"}),", ",(0,i.jsx)(t.code,{children:"StateWatcher<T>"}),", and ",(0,i.jsx)(t.code,{children:"StateWriter<T>"})," traits, which provide access to the state."]}),"\n",(0,i.jsxs)(t.h3,{id:"statereader",children:["StateReader",(0,i.jsx)(t.t,{})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"StateReader<T>"})," trait provides read-only access to the state. Through the implementation of ",(0,i.jsx)(t.code,{children:"StateReader<T>"}),", you can obtain a read reference to the state."]}),"\n",(0,i.jsxs)(t.h3,{id:"statewatcher",children:["StateWatcher",(0,i.jsx)(t.t,{})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"StateWatcher<T>"})," trait provides read-only access to the state. But unlike ",(0,i.jsx)(t.code,{children:"StateReader<T>"}),", through the implementation of ",(0,i.jsx)(t.code,{children:"StateWatcher<T>"}),", you get a subscription to the state changes of the host ",(0,i.jsx)(t.code,{children:"T"})," (i.e., when the state of the host ",(0,i.jsx)(t.code,{children:"T"})," changes, you will be notified)."]}),"\n",(0,i.jsxs)(t.h3,{id:"statewriter",children:["StateWriter",(0,i.jsx)(t.t,{})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"StateWriter<T>"})," trait provides write access to the state. Through the implementation of ",(0,i.jsx)(t.code,{children:"StateWriter<T>"}),", you can obtain a write reference to the state of the host ",(0,i.jsx)(t.code,{children:"T"}),". When the modification to the mut ref is completed, Ribir will automatically notify all UI parts dependent on that data."]}),"\n",(0,i.jsx)(t.h2,{id:"reading-and-writing-state",children:"Reading and Writing State"}),"\n",(0,i.jsxs)(t.p,{children:["In the ",(0,i.jsx)(t.code,{children:"fn_widget!"})," DSL, you can use specific syntax helpers to access state:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"$read(state)"})}),": Obtains a read reference to the state via ",(0,i.jsx)(t.code,{children:"StateReader<T>"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"$reader(impl StateReader<T>)"})}),": Obtains a clone of ",(0,i.jsx)(t.code,{children:"StateReader<T>"}),", typically used to hold read permission in a closure."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"$watcher(impl StateWatcher<T>)"})}),": Obtains a clone of ",(0,i.jsx)(t.code,{children:"StateWatcher<T>"}),", typically used to hold subscription permission in a closure."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"$writer(impl StateWriter<T>)"})}),": Obtains a clone of ",(0,i.jsx)(t.code,{children:"StateWriter<T>"}),", typically used to hold write permission in a closure."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Important"}),": The ",(0,i.jsx)(t.code,{children:"$read"}),", ",(0,i.jsx)(t.code,{children:"$write"}),", ",(0,i.jsx)(t.code,{children:"pipe!"}),", ",(0,i.jsx)(t.code,{children:"watch!"})," operators are ",(0,i.jsx)(t.strong,{children:"DSL-specific"})," and only work within macros that support the Ribir DSL syntax, such as ",(0,i.jsx)(t.code,{children:"fn_widget!"})," and ",(0,i.jsx)(t.code,{children:"rdl!"}),". These operators are not valid Rust syntax outside of these macros and will cause compilation errors if used in regular Rust code or nested within third-party macros."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": Outside of DSL macros, you can use ",(0,i.jsx)(t.code,{children:".read()"})," and ",(0,i.jsx)(t.code,{children:".write()"})," methods on the ",(0,i.jsx)(t.code,{children:"Stateful"})," object, but these do not establish reactive dependencies automatically."]}),"\n",(0,i.jsx)(t.h2,{id:"dsl-operators-in-third-party-macros",children:"DSL Operators in Third-Party Macros"}),"\n",(0,i.jsxs)(t.p,{children:["The DSL operators (",(0,i.jsx)(t.code,{children:"@"}),", ",(0,i.jsx)(t.code,{children:"$read"}),", ",(0,i.jsx)(t.code,{children:"$write"}),", etc.) are ",(0,i.jsx)(t.strong,{children:"not valid"})," when nested inside third-party macros. This is because we cannot anticipate the processing logic of third-party macros. For example:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"\u274c Invalid usage:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:'fn_widget! {\n    ...\n    // This will NOT work - $read is processed by println! which doesn\'t understand DSL syntax\n    println!("{}", $read(some_state));\n    ...\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"\u2705 Valid usage:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:'fn_widget! {\n    ...\n    let val = $read(some_state);\n    println!("{}", val);\n    ...\n}\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"simplified-state-access-in-fn_widget-closures",children:["Simplified State Access in ",(0,i.jsx)(t.code,{children:"fn_widget!"})," Closures"]}),"\n",(0,i.jsxs)(t.p,{children:["When using event handlers (like ",(0,i.jsx)(t.code,{children:"on_tap"}),") inside ",(0,i.jsx)(t.code,{children:"fn_widget!"}),", you often need to modify state. Ribir's helper macros (",(0,i.jsx)(t.code,{children:"$write"}),", ",(0,i.jsx)(t.code,{children:"$read"}),", ",(0,i.jsx)(t.code,{children:"$writer"}),", ",(0,i.jsx)(t.code,{children:"$reader"}),", ",(0,i.jsx)(t.code,{children:"$watcher"}),") are designed to work seamlessly with ",(0,i.jsx)(t.code,{children:"move"})," closures."]}),"\n",(0,i.jsxs)(t.p,{children:["They automatically detect when they are used inside a closure and handle the necessary cloning of the underlying state writer/reader. This means you rarely need to manually call ",(0,i.jsx)(t.code,{children:".clone_writer()"})," before the closure."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Verbose (Old Way):"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"let writer = state.clone_writer();\n@Button {\n    on_tap: move |_| {\n        *writer.write() += 1; // Manually cloned writer used here\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Simplified (Recommended):"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"@Button {\n    on_tap: move |_| {\n        *$write(state) += 1; // Automatic cloning handled by $write\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.h2,{id:"reactive-binding-with-pipe",children:["Reactive Binding with ",(0,i.jsx)(t.code,{children:"pipe!"})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"pipe!"})," macro is the primary way to bind state to widget properties. It evaluates an expression and re-evaluates it whenever any state marked with ",(0,i.jsx)(t.code,{children:"$read"})," or ",(0,i.jsx)(t.code,{children:"$write"})," inside the expression changes."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"pipe!"})," creates a one-way data flow: from State to View."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn counter_example() -> Widget<\'static> {\n    fn_widget! {\n        let count = Stateful::new(0);\n        \n        @Column {\n            // Bind the text property to the count state\n            @Text { \n                text: pipe!($read(count).to_string()) \n            }\n            @Button {\n                // Increment count on tap\n                on_tap: move |_| *$write(count) += 1,\n                @Text { text: "Increment" }\n            }\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"In this example:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pipe!($read(count).to_string())"})," creates a dynamic value."]}),"\n",(0,i.jsxs)(t.li,{children:["Initially, it reads ",(0,i.jsx)(t.code,{children:"count"}),' (0) and returns "0".']}),"\n",(0,i.jsxs)(t.li,{children:["When ",(0,i.jsx)(t.code,{children:"on_tap"})," executes ",(0,i.jsx)(t.code,{children:"*$write(count) += 1"}),", ",(0,i.jsx)(t.code,{children:"count"})," changes."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"pipe!"})," detects the change, re-runs ",(0,i.jsx)(t.code,{children:".to_string()"}),", and updates the ",(0,i.jsx)(t.code,{children:"Text"})," widget."]}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"important-avoid-using-buildctx-inside-pipe-expressions",children:["Important: Avoid Using ",(0,i.jsx)(t.code,{children:"BuildCtx"})," Inside ",(0,i.jsx)(t.code,{children:"pipe!"})," Expressions"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"pipe!"})," expressions are re-evaluated whenever their dependent state changes. However, ",(0,i.jsx)(t.code,{children:"BuildCtx"})," (build context) is only valid during the widget's build phase. Using ",(0,i.jsx)(t.code,{children:"BuildCtx::get()"})," inside a ",(0,i.jsx)(t.code,{children:"pipe!"})," expression will cause a runtime error when the expression is re-evaluated, as it attempts to access an invalid context."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["[!WARNING]\n",(0,i.jsx)(t.strong,{children:"Runtime Error Risk"}),": Never use ",(0,i.jsx)(t.code,{children:"BuildCtx::get()"})," directly inside a ",(0,i.jsx)(t.code,{children:"pipe!"})," expression. It will panic when the pipe updates. See ",(0,i.jsx)(t.a,{href:"../getting_started/troubleshooting.md#buildctxget-inside-pipe",children:"Troubleshooting"})," for more details."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Incorrect Example:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'/// This is an incorrect example that will cause a runtime error!\nuse ribir::prelude::*;\n\nfn bad_example() -> Widget<\'static> {\n    fn_widget! {\n        let count = Stateful::new(0);\n        @Text {\n            // Error: BuildCtx::get() may be invalid when pipe! re-evaluates\n            text: pipe!(*$read(count)).map(move |c| format!("tap {} on windows {:?}", c, BuildCtx::get().window().id())),\n            on_tap: move |_| *$write(count) += 1,\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Correct Approach:"})}),"\n",(0,i.jsxs)(t.p,{children:["If you need to access information from ",(0,i.jsx)(t.code,{children:"BuildCtx"}),", capture it at the top level of ",(0,i.jsx)(t.code,{children:"fn_widget!"})," and use it as a dependency or constant in the ",(0,i.jsx)(t.code,{children:"pipe!"})," expression."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn good_example() -> Widget<\'static> {\n    fn_widget! {\n        let count = Stateful::new(0);\n        // Capture window ID during build phase and use it as a constant in pipe!\n        let window_id = BuildCtx::get().window().id();\n        @Text {\n            text: pipe!(*$read(count)).map(move |c| format!("tap {} on windows {:?}", c, window_id)),\n            on_tap: move |_| *$write(count) += 1,\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"reacting-to-changes-with-watch",children:["Reacting to Changes with ",(0,i.jsx)(t.code,{children:"watch!"})]}),"\n",(0,i.jsxs)(t.p,{children:["While ",(0,i.jsx)(t.code,{children:"pipe!"})," is for binding values to properties, ",(0,i.jsx)(t.code,{children:"watch!"})," is for performing side effects (like logging, network requests, or complex logic) when state changes."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"watch!"})," creates an observable stream (rxRust stream). You must ",(0,i.jsx)(t.code,{children:".subscribe()"})," to it to execute code."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn watch_example() {\n    let count = Stateful::new(0);\n\n    // Watch for changes and print them\n    let _subscription = watch!(*$read(count))\n        .subscribe(|val| println!("Count changed to: {}", val));\n\n    *count.write() = 1; // Prints: Count changed to: 1\n    *count.write() = 2; // Prints: Count changed to: 2\n}\n'})}),"\n",(0,i.jsxs)(t.h3,{id:"pipe-vs-watch",children:[(0,i.jsx)(t.code,{children:"pipe!"})," vs ",(0,i.jsx)(t.code,{children:"watch!"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"pipe!(expr)"})}),": Returns a value (or a stream of values) intended for ",(0,i.jsx)(t.strong,{children:"initializing and updating widget properties"}),". It always has an initial value."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"watch!(expr)"})}),": Returns a stream. It is used for ",(0,i.jsx)(t.strong,{children:"side effects"}),". It does not emit an initial value, and you must explicitly subscribe to it."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"advanced-mapped--distinct-pipes",children:"Advanced: Mapped & Distinct Pipes"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"pipe!"})," can be combined with rxRust operators for more control. Since ",(0,i.jsx)(t.code,{children:"Pipe"})," wraps the underlying stream, you can use ",(0,i.jsx)(t.code,{children:".transform()"})," to access the full power of rxRust operators."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn advanced_pipe() -> Widget<\'static> {\n    fn_widget! {\n        let count = Stateful::new(0);\n        @Row {\n            @Text {\n                // Only update the text if the value is even\n                text: pipe!(*$read(count))\n                    .transform(|s| s.filter(|v| v % 2 == 0).box_it())\n                    .map(|v| format!("Even number: {}", v))\n            }\n            @Button {\n                on_tap: move |_| *$write(count) += 1,\n                @{"Increment" }\n            }\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Common operators include ",(0,i.jsx)(t.code,{children:".map()"}),", ",(0,i.jsx)(t.code,{children:".filter()"}),", ",(0,i.jsx)(t.code,{children:".distinct_until_changed()"}),", etc. Use ",(0,i.jsx)(t.code,{children:".transform()"})," when you need operators that change the stream structure or logic beyond simple mapping."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>d});var i=n(6540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);