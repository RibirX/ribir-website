"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3800],{1607:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=i(4848),o=i(8453);const a={sidebar_position:1},r="Introduction",s={id:"introduction",title:"Introduction",description:"In this chapter, we will use the Ribir syntax to write some simple examples. You only need to understand the general idea, we'll go into more detail in the following chapters.",source:"@site/versioned_docs/version-0.2.x/introduction.md",sourceDirName:".",slug:"/introduction",permalink:"/docs/introduction",draft:!1,unlisted:!1,tags:[],version:"0.2.x",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1771339632e3,sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Getting Started",permalink:"/docs/category/getting-started"}},d={},l=[{value:"What is Ribir?",id:"what-is-ribir",level:2},{value:"Why choose Ribir?",id:"why-choose-ribir",level:2},{value:"Non-intrusive programming model",id:"non-intrusive-programming-model",level:3},{value:"Consistent experience across multiple platforms, and easy to expand to new platforms",id:"consistent-experience-across-multiple-platforms-and-easy-to-expand-to-new-platforms",level:3},{value:"The Declarative syntax that is easy to interact with Rust",id:"the-declarative-syntax-that-is-easy-to-interact-with-rust",level:3},{value:"Point-to-point view update strategy",id:"point-to-point-view-update-strategy",level:3},{value:"&quot;Pay-as-you-go&quot; design principle",id:"pay-as-you-go-design-principle",level:3},{value:"Reliability",id:"reliability",level:3},{value:"What is the current status of Ribir?",id:"what-is-the-current-status-of-ribir",level:2},{value:"Stability",id:"stability",level:3},{value:"Platform coverage",id:"platform-coverage",level:3},{value:"Performance",id:"performance",level:3},{value:"Who is using Ribir?",id:"who-is-using-ribir",level:3}];function c(e){const t={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"In this chapter, we will use the Ribir syntax to write some simple examples. You only need to understand the general idea, we'll go into more detail in the following chapters."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"what-is-ribir",children:"What is Ribir?"}),"\n",(0,n.jsx)(t.p,{children:"Ribir is an open-source Rust framework for building beautiful, native, multi-platform applications from a single codebase."}),"\n",(0,n.jsx)(t.p,{children:"Ribir uses a non-intrusive declarative programming model that allows you to develop and design user interfaces as an independent module."}),"\n",(0,n.jsx)(t.p,{children:"Its core design concept is:"}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"The UI is a re-description of data interaction and continues to respond to modifications of data."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'The "re" here signifies that the API serves as the initial description of the data interaction. When building with Ribir, developers only need to focus on the data API to create the UI.'}),"\n",(0,n.jsx)(t.h2,{id:"why-choose-ribir",children:"Why choose Ribir?"}),"\n",(0,n.jsx)(t.h3,{id:"non-intrusive-programming-model",children:"Non-intrusive programming model"}),"\n",(0,n.jsx)(t.p,{children:"Ribir only interacts with the API of your data and does not require any pre-design of your data for the user interface:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"No additional states"}),"\n",(0,n.jsx)(t.li,{children:"No additional notification mechanisms"}),"\n",(0,n.jsx)(t.li,{children:"No inheritance of any base classes"}),"\n",(0,n.jsx)(t.li,{children:"No other pre-constraints."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"It doesn't break the logic and structure of your existing data or inject any additional objects. When developing the core part of an application, you can focus on designing the data, logic, and API of the application without thinking about the UI at all."}),"\n",(0,n.jsx)(t.p,{children:"The UI directly operates data, and data modifications directly drive UI updates, without any intermediate layers and concepts."}),"\n",(0,n.jsx)(t.h3,{id:"consistent-experience-across-multiple-platforms-and-easy-to-expand-to-new-platforms",children:"Consistent experience across multiple platforms, and easy to expand to new platforms"}),"\n",(0,n.jsx)(t.p,{children:"Ribir can be used to develop desktop, mobile, web and server-side rendering applications. It generates efficient binary code or WASM programs without relying on any runtime environment. It outputs a very simple, platform-independent drawing result, allowing you to choose to be rendered entirely by the GPU or CPU. You can even easily implement your own rendering backend to expand to uncovered platforms."}),"\n",(0,n.jsx)(t.h3,{id:"the-declarative-syntax-that-is-easy-to-interact-with-rust",children:"The Declarative syntax that is easy to interact with Rust"}),"\n",(0,n.jsx)(t.p,{children:"Ribir provides a declarative syntax that is easy to interact with Rust. It is not a new language, but a set of Rust macros. Therefore, it can interact well with Rust, making your code both a clear view description and a powerful logical expression, without any environment and tool dependencies."}),"\n",(0,n.jsx)(t.h3,{id:"point-to-point-view-update-strategy",children:"Point-to-point view update strategy"}),"\n",(0,n.jsx)(t.p,{children:"Ribir will map a view tree based on your description of the data, and the view will be updated in response to data modifications - this update does not rebuild the entire view, but updates the parts of the view that depend on the modified data point-to-point."}),"\n",(0,n.jsx)(t.p,{children:"The update logic is determined at compile time, and there is no general diff or patch algorithm to execute at runtime."}),"\n",(0,n.jsx)(t.h3,{id:"pay-as-you-go-design-principle",children:'"Pay-as-you-go" design principle'}),"\n",(0,n.jsx)(t.p,{children:"Due to the need to handle multiple complex real-life situations, a general GUI framework tends to have complex designs and extensive features. As a result, it is difficult to keep it lightweight. The way Ribir balances this problem is to provide enough capabilities to ensure development efficiency, and requiring that all capabilities only need to be understood and have overhead when they are used. A few examples:"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Pure composition"}),": Ribir uses widgets to build interfaces. Unlike common object-oriented GUI frameworks, Ribir widgets do not need to inherit a base class or hold a base object. It is a pure composition model, even the parent-child relationship and built-in fields are completed through composition. The advantage of this is that the widget only needs to focus on the capabilities it provides, so it can be made very small to improve reuse. For example, Ribir has many very mini built-in widgets, and using these built-in widgets to extend ordinary widgets is powerful, but does not bring any overhead to them. For example:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn_widget!{\n  @Text {\n    // `margin` is not a field of `Text`,\n    // it is a field of the built-in widget `Margin`,\n    // but it can still be used directly by `Text`.\n    margin: EdgeInsets::all(8.),\n    text: "Hello world!"\n  }\n};\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The above example shows the way of combining built-in widgets. Even if ",(0,n.jsx)(t.code,{children:"Text"})," does not have a ",(0,n.jsx)(t.code,{children:"margin"})," field, you can still use the ",(0,n.jsx)(t.code,{children:"Margin::margin"})," and compose it with ",(0,n.jsx)(t.code,{children:"Text"})," to form a new widget. ",(0,n.jsx)(t.code,{children:"Margin"})," will only be created when a widget uses the ",(0,n.jsx)(t.code,{children:"margin"})," field, otherwise, there will be no overhead."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Digestion of compose widget"}),": When describing the view of the data, in addition to some basic widgets, most widgets are composed of other widgets. For instance, a ",(0,n.jsx)(t.code,{children:"Button"})," is an assembly of elements like ",(0,n.jsx)(t.code,{children:"Text"}),", ",(0,n.jsx)(t.code,{children:"Icon"}),", and ",(0,n.jsx)(t.code,{children:"BoxDecoration"}),". The ",(0,n.jsx)(t.code,{children:"Button"})," itself isn't a visual component; we refer to such a widget as a compose widget. Compose widgets will be digested during view construction. They are similar to a function that is invoked once during view construction and do not exist in the final view."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Sateful without writing source will convert to Stateless"}),": Unlike other declarative frameworks that add fields to widgets to control widget updates. Ribir is non-intrusive. Ribir treats the entire widget as a state to control updates. It provides the ability to split the state so that the local view can directly depend on the modification of part of the data to update (introduced in detail in the subsequent tutorial). Another big difference is that stateful and stateless can be converted to each other. If a state has no write source, it will degenerate into stateless\uff0c because no one will update it. For example:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn_widget!{\n  let show_hi = Stateful::new(true);\n  @Text {\n    visible: pipe!(*$show_hi),\n    text: "Hello world!"\n  }\n};\n'})}),"\n",(0,n.jsxs)(t.p,{children:["In the above example, we declared a ",(0,n.jsx)(t.code,{children:"Text"})," and used the ",(0,n.jsx)(t.code,{children:"pipe!"})," macro to directly associate the visibility of ",(0,n.jsx)(t.code,{children:"Text"})," with ",(0,n.jsx)(t.code,{children:"show_hi"}),". But this association will be removed when the view is constructed because ",(0,n.jsx)(t.code,{children:"show_hi"})," has no written source. Therefore, Ribir constructs a simple static view."]}),"\n",(0,n.jsx)(t.h3,{id:"reliability",children:"Reliability"}),"\n",(0,n.jsx)(t.p,{children:"Unlike general GUI frameworks that use inheritance and do not have any type constraints except base class inheritance, Ribir builds views based on widget composition and relies on the types between parent and child widgets to constrain whether and how to compose them. You can standardize your child types, so many errors can be reported at compile time instead of being checked at runtime."}),"\n",(0,n.jsx)(t.h2,{id:"what-is-the-current-status-of-ribir",children:"What is the current status of Ribir?"}),"\n",(0,n.jsx)(t.h3,{id:"stability",children:"Stability"}),"\n",(0,n.jsx)(t.p,{children:"The core framework of Ribir is in a stable state, and the API and syntax will be iterated with a cautious attitude. Although the widget library already has many available widgets, it is still in a very rough state, and each version will have major changes."}),"\n",(0,n.jsx)(t.h3,{id:"platform-coverage",children:"Platform coverage"}),"\n",(0,n.jsx)(t.p,{children:"The 0.1 version only covers the Mac, Linux and Windows platforms. You can try to compile the project to the corresponding mobile and web ends, but they have not been verified."}),"\n",(0,n.jsx)(t.h3,{id:"performance",children:"Performance"}),"\n",(0,n.jsx)(t.p,{children:"In all important designs of the entire framework, performance is an important factor we consider. According to the performance of real development projects we have observed, the overall experience meets expectations. We expect it to eventually have excellent performance. But to be honest, we have never done any detailed performance measurement and analysis, so we have not done any code optimization work. We expect this work to be carried out comprehensively after the full platform coverage and the widget library are relatively stable - or we have encountered detailed performance bottlenecks before that."}),"\n",(0,n.jsx)(t.h3,{id:"who-is-using-ribir",children:"Who is using Ribir?"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Polestar Chat"}),":"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Sisyphus"}),": An editor for editing interactive documents, this is a long-term project, that is still in the early design and development stage, and it is the idea of this project that led to the birth of Ribir."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>s});var n=i(6540);const o={},a=n.createContext(o);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);