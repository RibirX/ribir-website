"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7955],{3203:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});var n=i(4848),o=i(8453);const r={sidebar_position:2},l='Using Ribir without "DSL"',s={id:"understanding_ribir/without_dsl",title:'Using Ribir without "DSL"',description:'Whether you want clearer debugging or more Rust-like code, you might choose not to use Ribir\'s "DSL".',source:"@site/versioned_docs/version-0.2.x/understanding_ribir/without_dsl.md",sourceDirName:"understanding_ribir",slug:"/understanding_ribir/without_dsl",permalink:"/docs/understanding_ribir/without_dsl",draft:!1,unlisted:!1,tags:[],version:"0.2.x",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1735632227e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Widgets in Depth",permalink:"/docs/understanding_ribir/widget_in_depth"}},d={},a=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Creating a widget with the API",id:"creating-a-widget-with-the-api",level:2},{value:"Extending Widget Functionality with <code>FatObj</code>",id:"extending-widget-functionality-with-fatobj",level:3},{value:"Why should we use <code>Declare</code> to create widgets?",id:"why-should-we-use-declare-to-create-widgets",level:3},{value:"Interacting with <code>BuildCtx</code>",id:"interacting-with-buildctx",level:4},{value:"Full Setup API",id:"full-setup-api",level:4},{value:"Supports Initialization with <code>pipe!</code> Stream",id:"supports-initialization-with-pipe-stream",level:4},{value:"How to Access Built-in Widget Properties",id:"how-to-access-built-in-widget-properties",level:4},{value:"Composing Child Widgets",id:"composing-child-widgets",level:2},{value:"Mixing API and Macros",id:"mixing-api-and-macros",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"using-ribir-without-dsl",children:'Using Ribir without "DSL"'}),"\n",(0,n.jsx)(t.p,{children:'Whether you want clearer debugging or more Rust-like code, you might choose not to use Ribir\'s "DSL".'}),"\n",(0,n.jsx)(t.p,{children:"Don't worry. Ribir was designed to use \"DSL\" as a simple syntax layer. You can use Ribir's API to build UI directly. Even in a single piece of code, you can choose to use the API and macros together. Everything will be simple and natural."}),"\n",(0,n.jsx)(t.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,n.jsx)(t.p,{children:"In Ribir:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Views are built as basic units of widgets."}),"\n",(0,n.jsxs)(t.li,{children:["Widgets are ",(0,n.jsxs)(t.a,{href:"/docs/understanding_ribir/widget_in_depth#pure-composition",children:["composed ",(0,n.jsx)(t.strong,{children:"purely"})]})," from other widgets."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"So, building a UI with the API mainly involves two key points:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"How to create a widget"}),"\n",(0,n.jsx)(t.li,{children:"How to compose child widgets"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"creating-a-widget-with-the-api",children:"Creating a widget with the API"}),"\n",(0,n.jsxs)(t.p,{children:["Let's take the ",(0,n.jsx)(t.code,{children:"FilledButton"})," widget as an example. Its definition is as follows:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nstruct FilledButton {\n  color: Color\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"This is just like a regular Rust structure. You can directly create an object:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nlet button = FilledButton { color: Color::RED };\n"})}),"\n",(0,n.jsx)(t.p,{children:"And there you have it, a red button."}),"\n",(0,n.jsxs)(t.h3,{id:"extending-widget-functionality-with-fatobj",children:["Extending Widget Functionality with ",(0,n.jsx)(t.code,{children:"FatObj"})]}),"\n",(0,n.jsx)(t.p,{children:"We've created a button, but it doesn't have any API for handling events."}),"\n",(0,n.jsx)(t.p,{children:"In Ribir, event handling is implemented by separate widgets, not directly in the button itself. Any widget can gain event handling capabilities by compose with it."}),"\n",(0,n.jsxs)(t.p,{children:["For built-in widgets like event handlers, you don't need to compose them to use their features. Ribir offers a generic called ",(0,n.jsx)(t.code,{children:"FatObj<T>"}),", which has initialization APIs for all built-in widgets. Simply wrap your widget with it, and your widget will have all the features of the built-in widgets."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nlet button = FilledButton { color: Color::RED };\nlet button = FatObj::new(button)\n  .on_tap(|_| println!("Button tapped"));\n'})}),"\n",(0,n.jsxs)(t.p,{children:["But in practice, we usually don't write it directly like this. Instead, we create widgets using the ",(0,n.jsx)(t.code,{children:"Declare"})," trait."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn button_demo(ctx: &BuildCtx) {\n  let btn: FatObj<State<FilledButton>> = FilledButton::declarer()\n    .color(Color::RED)\n    .on_tap(|_| println!("Button clicked"))\n    .finish(ctx);\n}\n'})}),"\n",(0,n.jsxs)(t.h3,{id:"why-should-we-use-declare-to-create-widgets",children:["Why should we use ",(0,n.jsx)(t.code,{children:"Declare"})," to create widgets?"]}),"\n",(0,n.jsx)(t.p,{children:"In the previous example, we used a method similar to the Builder pattern to create a widget. This might seem more complicated, but it actually has several benefits."}),"\n",(0,n.jsxs)(t.h4,{id:"interacting-with-buildctx",children:["Interacting with ",(0,n.jsx)(t.code,{children:"BuildCtx"})]}),"\n",(0,n.jsxs)(t.p,{children:["First, let's look at the complete definition of ",(0,n.jsx)(t.code,{children:"FillButton"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\n#[derive(Declare, Default)]\npub struct FilledButton {\n  #[declare(default=Palette::of(ctx!()).primary())]\n  pub color: Color,\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Note the attribute ",(0,n.jsx)(t.code,{children:"#[declare(default=Palette::of(ctx!()).primary())]"}),". This means that if you don't set a ",(0,n.jsx)(t.code,{children:"color"})," value when creating ",(0,n.jsx)(t.code,{children:"FilledButton"})," with ",(0,n.jsx)(t.code,{children:"Declare"}),", it will use the primary color from the palette as the default."]}),"\n",(0,n.jsxs)(t.p,{children:["This is the main reason we use ",(0,n.jsx)(t.code,{children:"Declare"})," to create widgets: it allows widgets to access ",(0,n.jsx)(t.code,{children:"BuildCtx"})," when they're created. This lets widgets automatically configure themselves based on the context, like changing dynamically with the theme."]}),"\n",(0,n.jsx)(t.h4,{id:"full-setup-api",children:"Full Setup API"}),"\n",(0,n.jsxs)(t.p,{children:["Another thing to note is that we're creating ",(0,n.jsx)(t.code,{children:"FatObj<State<FilledButton>>"}),", not ",(0,n.jsx)(t.code,{children:"FilledButton"}),". This is because ",(0,n.jsx)(t.code,{children:"Declare"})," allows us to configure properties with methods of the same name and also use ",(0,n.jsx)(t.code,{children:"FatObj"})," to extend the capabilities of built-in widgets. We use ",(0,n.jsx)(t.code,{children:"State"})," because it lets your widget's state be observed and modified, which is a very common capability. For example, we might want the button's color to change to blue when clicked."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nfn button_demo(ctx: &BuildCtx){\n  let mut btn: FatObj<State<FilledButton>> = FilledButton::declarer()\n    .color(Color::RED)\n    .finish(ctx);\n\n  let w = btn.clone_writer();\n  btn = btn.on_tap(move |_| w.write().color = Color::BLUE);\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Naturally, whether you're using ",(0,n.jsx)(t.code,{children:"FatObj"})," or ",(0,n.jsx)(t.code,{children:"State"}),", any associated overhead is only added to the final view you build when you utilize their provided capabilities."]}),"\n",(0,n.jsxs)(t.h4,{id:"supports-initialization-with-pipe-stream",children:["Supports Initialization with ",(0,n.jsx)(t.code,{children:"pipe!"})," Stream"]}),"\n",(0,n.jsxs)(t.p,{children:["Another benefit of using ",(0,n.jsx)(t.code,{children:"Declare"})," to create widgets is that it allows for property initialization through the ",(0,n.jsx)(t.code,{children:"pipe!"})," stream. Properties set up with the ",(0,n.jsx)(t.code,{children:"pipe!"})," stream will adapt as the stream changes. For instance, let's say we want to create two ",(0,n.jsx)(t.code,{children:"FilledButton"}),"s, and we want ",(0,n.jsx)(t.code,{children:"btn2"}),"'s color to change in sync with ",(0,n.jsx)(t.code,{children:"btn1"}),"'s color."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nfn button_demo(ctx: &BuildCtx){\n  let btn1 = FilledButton::declarer().color(Color::RED).finish(ctx);\n\n  let btn2 = FilledButton::declarer()\n    .color(pipe!($btn1.color))\n    .finish(ctx);\n\n  btn1.write().color = Color::BLUE;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["When we change the color of ",(0,n.jsx)(t.code,{children:"btn1"}),", the color of ",(0,n.jsx)(t.code,{children:"btn2"})," will also change accordingly."]}),"\n",(0,n.jsx)(t.h4,{id:"how-to-access-built-in-widget-properties",children:"How to Access Built-in Widget Properties"}),"\n",(0,n.jsxs)(t.p,{children:["It's important to note that although widgets created with ",(0,n.jsx)(t.code,{children:"Declare"})," can directly configure all built-in capabilities, if you need to modify the properties of a built-in widget after initialization, you need to first get the corresponding built-in widget and then operate on it. This is because these built-in widgets are composed as needed. In the example below, we create a button and change its margin when clicked."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nfn button_demo(ctx: &BuildCtx){\n  let mut btn = FilledButton::declarer()\n    .color(Color::RED)\n    .finish(ctx);\n\n  let m = btn.get_margin_widget().clone_writer();\n  btn = btn.on_tap(move |_| m.write().margin = EdgeInsets::all(10.0));\n}\n\n"})}),"\n",(0,n.jsx)(t.h2,{id:"composing-child-widgets",children:"Composing Child Widgets"}),"\n",(0,n.jsxs)(t.p,{children:["In Ribir, we use the ",(0,n.jsx)(t.code,{children:"with_child"})," method to compose a child widget with a parent widget to form a new widget. And the ",(0,n.jsx)(t.code,{children:"@"})," syntax primarily uses ",(0,n.jsx)(t.code,{children:"with_child"})," for its implementation. You might find yourself using this more often than you'd expect."]}),"\n",(0,n.jsxs)(t.p,{children:["For example, for a ",(0,n.jsx)(t.code,{children:"FilledButton"}),", the displayed text is also a child widget, not a property of it. This is because it can either be a text button or an icon button. If these were properties, memory would be allocated for the properties you don't need, whether you're using a text button or an icon button. But if it's a child widget, you can compose as needed."]}),"\n",(0,n.jsx)(t.p,{children:"Here's an example of a text button and an icon button:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn button_demo(ctx: &BuildCtx){\n  let text_btn = FilledButton::declarer()\n    .color(Color::RED)\n    .finish(ctx)\n    .with_child(Label::new("Text Button"), ctx);\n\n  let icon_btn = FilledButton::declarer()\n    .color(Color::RED)\n    .finish(ctx)\n    .with_child(svgs::ADD, ctx);\n}\n'})}),"\n",(0,n.jsx)(t.h2,{id:"mixing-api-and-macros",children:"Mixing API and Macros"}),"\n",(0,n.jsxs)(t.p,{children:["Ribir's \"DSL\" is not a new language, but a set of macros. Each macro can be used as an independent expression, so you can freely mix them. Below, we'll implement an example of a counter. We'll create the buttons and the counter text directly through the API, and use ",(0,n.jsx)(t.code,{children:"$"})," when initializing their properties to avoid cloning ",(0,n.jsx)(t.code,{children:"cnt"}),". Finally, we'll use the ",(0,n.jsx)(t.code,{children:"@"})," syntax to combine them into a ",(0,n.jsx)(t.code,{children:"Row"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nlet counter = fn_widget! {\n  let cnt = Stateful::new(0);\n  let btn = FilledButton::declarer()\n    .on_tap(move |_| *$cnt.write() += 1)\n    .finish(ctx!())\n    .with_child(Label::new("Inc"), ctx!());\n\n  let label = H1::declarer()\n    .text(pipe!($cnt.to_string()))\n    .finish(ctx!());\n\n  @Row {\n    @ { btn }\n    @ { label }\n  }\n};\n'})}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(t.p,{children:'We hope that everyone using Ribir can choose their preferred way of using it, whether through the "DSL" or directly using the API, to get the best experience.'}),"\n",(0,n.jsx)(t.p,{children:'But what you need to understand is that Ribir\'s "DSL" is not a new language, we don\'t even call it "DSL". It\'s entirely built on the API we introduced above, just a set of macros, aimed at making the UI structure clearer, more readable, and avoiding some obvious repetitive code, such as frequent cloning of State due to move semantics.'}),"\n",(0,n.jsxs)(t.p,{children:["In short, you can choose to use it partially, or choose not to use it at all, everything is free, you don't have to be afraid of seeing new syntax. Keep exploring and enjoy your ",(0,n.jsx)(t.a,{href:"/docs/get_started/quick_start",children:"Ribir journey"}),"!"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>s});var n=i(6540);const o={},r=n.createContext(o);function l(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);