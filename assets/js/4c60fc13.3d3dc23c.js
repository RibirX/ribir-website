"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6387],{6757:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var t=n(4848),i=n(8453);const r={sidebar_position:2},l="Theming",a={id:"widgets/theming",title:"Theming",description:"Ribir provides a powerful and flexible theming system designed to help you build consistent and beautiful UIs. The color system is heavily inspired by Material Design principles but is fully customizable to fit any design language.",source:"@site/docs/widgets/theming.md",sourceDirName:"widgets",slug:"/widgets/theming",permalink:"/docs/next/widgets/theming",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1767168049e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Widget Components",permalink:"/docs/next/widgets/overview"},next:{title:"Advanced Topics",permalink:"/docs/next/category/advanced-topics"}},o={},d=[{value:"1. Palette (Colors)",id:"1-palette-colors",level:2},{value:"Using Colors",id:"using-colors",level:3},{value:"2. Typography (Text Styles)",id:"2-typography-text-styles",level:2},{value:"Accessing Text Styles",id:"accessing-text-styles",level:3},{value:"3. Classes (Styles)",id:"3-classes-styles",level:2},{value:"Using Classes",id:"using-classes",level:3},{value:"Step 1: Define Class Names",id:"step-1-define-class-names",level:4},{value:"Step 2: Use Classes in Your Widget",id:"step-2-use-classes-in-your-widget",level:4},{value:"Step 3: Provide Styles",id:"step-3-provide-styles",level:4},{value:"Classes in the Theme",id:"classes-in-the-theme",level:3},{value:"4. Icons",id:"4-icons",level:2},{value:"Managing Icons with SVG Registry",id:"managing-icons-with-svg-registry",level:3}];function c(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"theming",children:"Theming"}),"\n",(0,t.jsx)(s.p,{children:"Ribir provides a powerful and flexible theming system designed to help you build consistent and beautiful UIs. The color system is heavily inspired by Material Design principles but is fully customizable to fit any design language."}),"\n",(0,t.jsxs)(s.p,{children:["At its core, a ",(0,t.jsx)(s.code,{children:"Theme"})," in Ribir is a collection of:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Palette"}),": A comprehensive color system."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Typography"}),": A set of semantic text styles."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Classes"}),": A powerful mechanism to separate style logic from widget structure."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The current theme is always available in the build context. You can access it using ",(0,t.jsx)(s.code,{children:"Theme::of(ctx)"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"1-palette-colors",children:"1. Palette (Colors)"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"Palette"})," struct defines the color scheme for your application. It supports both light and dark modes via the ",(0,t.jsx)(s.code,{children:"Brightness"})," enum."]}),"\n",(0,t.jsxs)(s.p,{children:["Ribir's palette uses semantic naming (like ",(0,t.jsx)(s.code,{children:"primary"}),", ",(0,t.jsx)(s.code,{children:"secondary"}),", ",(0,t.jsx)(s.code,{children:"surface"}),", ",(0,t.jsx)(s.code,{children:"error"}),") rather than descriptive naming (like ",(0,t.jsx)(s.code,{children:"red"}),", ",(0,t.jsx)(s.code,{children:"blue"}),"). This ensures that your UI adapts correctly when the theme changes (e.g., switching from light to dark mode)."]}),"\n",(0,t.jsx)(s.h3,{id:"using-colors",children:"Using Colors"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn example() -> Widget<'static> {\n    fn_widget! {\n        let palette = Palette::of(BuildCtx::get());\n        @Container {\n            size: Size::new(100., 100.),\n            background: palette.primary(), // Accessing the primary color\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"2-typography-text-styles",children:"2. Typography (Text Styles)"}),"\n",(0,t.jsxs)(s.p,{children:["Ribir's typography system organizes text styles into semantic categories like ",(0,t.jsx)(s.code,{children:"Display"}),", ",(0,t.jsx)(s.code,{children:"Headline"}),", ",(0,t.jsx)(s.code,{children:"Title"}),", ",(0,t.jsx)(s.code,{children:"Label"}),", and ",(0,t.jsx)(s.code,{children:"Body"}),". Each category has ",(0,t.jsx)(s.code,{children:"Large"}),", ",(0,t.jsx)(s.code,{children:"Medium"}),", and ",(0,t.jsx)(s.code,{children:"Small"})," variations."]}),"\n",(0,t.jsx)(s.p,{children:"This structure allows you to define a consistent typographic hierarchy across your application."}),"\n",(0,t.jsx)(s.h3,{id:"accessing-text-styles",children:"Accessing Text Styles"}),"\n",(0,t.jsxs)(s.p,{children:["You can access the typography theme using ",(0,t.jsx)(s.code,{children:"TypographyTheme::of(ctx)"}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn text_style_example() -> Widget<\'static> {\n    fn_widget! {\n        let typography = TypographyTheme::of(BuildCtx::get());\n\n        @Column {\n            @Text {\n                text: "Main Title",\n                text_style: typography.display_large.text.clone(),\n            }\n            @Text {\n                text: "Subtitle",\n                text_style: typography.title_medium.text.clone(),\n            }\n            @Text {\n                text: "Body text goes here...",\n                text_style: typography.body_medium.text.clone(),\n            }\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,t.jsx)(s.h2,{id:"3-classes-styles",children:"3. Classes (Styles)"}),"\n",(0,t.jsxs)(s.p,{children:["One of Ribir's most powerful features is its ",(0,t.jsx)(s.code,{children:"Class"})," system. A ",(0,t.jsx)(s.code,{children:"Class"})," in Ribir is not just a collection of properties (like CSS classes); it is a ",(0,t.jsx)(s.strong,{children:"function that transforms a widget"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"This allows a class to:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Set properties (e.g., color, padding)."}),"\n",(0,t.jsx)(s.li,{children:"Wrap the widget (e.g., add a border or background container, add new elements, etc.)."}),"\n",(0,t.jsx)(s.li,{children:"Add behavior (e.g., event listeners)."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"using-classes",children:"Using Classes"}),"\n",(0,t.jsx)(s.h4,{id:"step-1-define-class-names",children:"Step 1: Define Class Names"}),"\n",(0,t.jsxs)(s.p,{children:["Use the ",(0,t.jsx)(s.code,{children:"class_names!"})," macro to define globally unique keys for your widget's styles."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nclass_names! {\n    /// The default class for MyCard\n    MY_CARD,\n    /// The class for MyCard's title\n    MY_CARD_TITLE\n}\n"})}),"\n",(0,t.jsx)(s.h4,{id:"step-2-use-classes-in-your-widget",children:"Step 2: Use Classes in Your Widget"}),"\n",(0,t.jsxs)(s.p,{children:["In your widget's ",(0,t.jsx)(s.code,{children:"compose"})," method, use these class names to apply styles from the current theme."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",metastring:"ignore",children:'#[derive(Declare)]\npub struct MyCard;\n\nimpl Compose for MyCard {\n    fn compose(this: impl StateWriter<Value = Self>) -> Widget<\'static> {\n        fn_widget! {\n            @Stack {\n                // Apply the main card style from the theme\n                class: MY_CARD,\n                @Text {\n                    text: "Card Title",\n                    // Apply the title style from the theme\n                    class: MY_CARD_TITLE,\n                }\n            }\n        }.into_widget()\n    }\n}\n'})}),"\n",(0,t.jsx)(s.h4,{id:"step-3-provide-styles",children:"Step 3: Provide Styles"}),"\n",(0,t.jsx)(s.p,{children:"We can provide styles for MyCard through providers."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nfn main() {\n    providers! {\n      // Provide the styles on the provider\n      providers: [\n        Class::provider(MY_CARD, move |w| {\n          fn_widget! {\n            @Container {\n              size: Size::new(100., 100.),\n              radius: Radius::all(12.),\n              clamp: BoxClamp::fixed_size(Size::splat(48.)),\n              @ { w }\n            }\n          }.into_widget()\n        }),\n        Class::provider(MY_CARD_TITLE, style_class!{\n          line_height: 24.,\n          foreground: Color::RED, // Set the text color\n        }),\n      ],\n      @MyCard {  }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Note"}),": For styles that add built-in attributes, Ribir provides the ",(0,t.jsx)(s.code,{children:"style_class!"})," macro to quickly generate styles."]}),"\n",(0,t.jsx)(s.h3,{id:"classes-in-the-theme",children:"Classes in the Theme"}),"\n",(0,t.jsxs)(s.p,{children:["In the theme, you can provide some default styles for components throughout the application. For example, the ",(0,t.jsx)(s.code,{children:"themes/material"})," provide Material classes for the Widgets component library that make the Widgets component library run like Material Design."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",metastring:"ignore",children:"use ribir_core::prelude::Classes;\n//...\n\npub fn theme() -> Classes {\n  let mut classes = Classes::default();\n  \n  buttons_cls::init(&mut classes); // Button styles\n  badge_cls::init(&mut classes); // Badge styles\n  // ..\n\n  Theme {\n    classes,\n    //...\n  }\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"4-icons",children:"4. Icons"}),"\n",(0,t.jsxs)(s.p,{children:["Icons in Ribir are managed separately from themes using the global ",(0,t.jsx)(s.code,{children:"svg_registry"})," module. This provides a centralized system for registering and retrieving SVG icons by name across your application."]}),"\n",(0,t.jsx)(s.h3,{id:"managing-icons-with-svg-registry",children:"Managing Icons with SVG Registry"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",metastring:"ignore",children:'use ribir::prelude::*;\n\nfn register_icons() {\n    // Register an SVG with a name\n    let my_svg = Svg::parse_from_bytes(\n        r#"<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">...</svg>"#.as_bytes(),\n        true,  // inherit_fill\n        false  // inherit_stroke\n    ).unwrap();\n\n    svg_registry::register("my_icon", my_svg);\n}\n\nfn icon_example() -> Widget<\'static> {\n    fn_widget! {\n        // Use the registered icon with fallback to default if not found\n        @Icon { @ { svg_registry::get_or_default("my_icon") } }\n    }.into_widget()\n}\n'})}),"\n",(0,t.jsx)(s.p,{children:"The SVG registry provides functions for:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"svg_registry::register(name, svg)"}),": Register an SVG with a specific name"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"svg_registry::get(name)"}),": Retrieve a named SVG (returns Option)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"svg_registry::get_or_default(name)"}),": Retrieve a named SVG or fallback to default"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>a});var t=n(6540);const i={},r=t.createContext(i);function l(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);