"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6575],{1474:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>c});var r=i(4848),s=i(8453);const t={},l="Built-in Attributes & FatObj",d={id:"guide/core_concepts/built_in_attributes_and_fat_obj",title:"Built-in Attributes & FatObj",description:"Ribir provides a powerful built-in attribute system that allows you to add common functionality to any Widget, such as layout control (margin, alignment), visual effects (background, border, opacity, transform), and interaction events (ontap, onhover). These features are not implemented individually by each Widget, but are provided through a universal wrapper called FatObj.",source:"@site/docs/guide/core_concepts/built_in_attributes_and_fat_obj.md",sourceDirName:"guide/core_concepts",slug:"/guide/core_concepts/built_in_attributes_and_fat_obj",permalink:"/docs/next/guide/core_concepts/built_in_attributes_and_fat_obj",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1766826148e3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Widget Components",permalink:"/docs/next/guide/advanced/widgets"},next:{title:"Data Sharing & Events",permalink:"/docs/next/guide/core_concepts/data_sharing_and_events"}},o={},c=[{value:"The <code>@</code> Instantiation Process",id:"the--instantiation-process",level:2},{value:"What <code>#[derive(Declare)]</code> Does",id:"what-derivedeclare-does",level:3},{value:"What is FatObj?",id:"what-is-fatobj",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Common Built-in Attributes",id:"common-built-in-attributes",level:2},{value:"1. Properties",id:"1-properties",level:3},{value:"2. Events",id:"2-events",level:3},{value:"Usage Scenarios",id:"usage-scenarios",level:2},{value:"Scenario 1: Declaring a New Widget",id:"scenario-1-declaring-a-new-widget",level:3},{value:"Scenario 2: Wrapping an Existing Widget",id:"scenario-2-wrapping-an-existing-widget",level:3},{value:"FatObj Core Mechanics",id:"fatobj-core-mechanics",level:2},{value:"Inner Wrapping Order of Built-in Attributes",id:"inner-wrapping-order-of-built-in-attributes",level:3},{value:"Key Takeaways",id:"key-takeaways",level:4},{value:"How to Override the Order?",id:"how-to-override-the-order",level:3},{value:"Advanced: Dynamic Access &amp; Modification",id:"advanced-dynamic-access--modification",level:2},{value:"Simple Follower Example (one component follows another)",id:"simple-follower-example-one-component-follows-another",level:3},{value:"Summary",id:"summary",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"built-in-attributes--fatobj",children:"Built-in Attributes & FatObj"}),"\n",(0,r.jsxs)(n.p,{children:["Ribir provides a powerful built-in attribute system that allows you to add common functionality to any Widget, such as layout control (margin, alignment), visual effects (background, border, opacity, transform), and interaction events (on_tap, on_hover). These features are not implemented individually by each Widget, but are provided through a universal wrapper called ",(0,r.jsx)(n.code,{children:"FatObj"}),"."]}),"\n",(0,r.jsxs)(n.h2,{id:"the--instantiation-process",children:["The ",(0,r.jsx)(n.code,{children:"@"})," Instantiation Process"]}),"\n",(0,r.jsxs)(n.p,{children:["When you use the ",(0,r.jsx)(n.code,{children:"@"})," syntax (e.g., ",(0,r.jsx)(n.code,{children:"@Text { ... }"}),") in ",(0,r.jsx)(n.code,{children:"fn_widget!"}),", Ribir performs the following steps to construct the widget:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Get the Builder"}),": It calls the ",(0,r.jsx)(n.code,{children:"declarer()"})," method from the ",(0,r.jsx)(n.code,{children:"Declare"})," trait to obtain the builder for the widget."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Initialize Fields"}),": For each field specified in the ",(0,r.jsx)(n.code,{children:"{ ... }"})," block, it calls the corresponding ",(0,r.jsx)(n.code,{children:"with_xxx()"})," method on the builder (e.g., ",(0,r.jsx)(n.code,{children:"with_text(...)"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Finish Construction"}),": Finally, it calls the builder's ",(0,r.jsx)(n.code,{children:"finish()"})," method (builder implements ",(0,r.jsx)(n.code,{children:"ObjDeclarer"})," trait), to complete the construction and return the declared widget."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"what-derivedeclare-does",children:["What ",(0,r.jsx)(n.code,{children:"#[derive(Declare)]"})," Does"]}),"\n",(0,r.jsxs)(n.p,{children:["To support the process above, the ",(0,r.jsx)(n.code,{children:"#[derive(Declare)]"})," macro automatically generates the necessary code for your widget:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It creates a ",(0,r.jsx)(n.strong,{children:"Builder struct"})," (e.g., ",(0,r.jsx)(n.code,{children:"TextBuilder"})," for ",(0,r.jsx)(n.code,{children:"Text"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["It implements the ",(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"Declare"})," trait"]})," for your widget, linking it to the builder."]}),"\n",(0,r.jsxs)(n.li,{children:["It generates ",(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"with_xxx"})," methods"]})," for each field, allowing you to set values fluently."]}),"\n",(0,r.jsxs)(n.li,{children:["It implements ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"ObjDeclarer"})})," for the builder, which handles the final build step ",(0,r.jsx)(n.code,{children:"finish()"})," and returns ",(0,r.jsx)(n.code,{children:"FatObj<Stateful<T>>"})," (where ",(0,r.jsx)(n.code,{children:"T"})," is the type of the widget being built)."]}),"\n",(0,r.jsxs)(n.li,{children:["It also generates a convenient macro for simple use. For example, after defining ",(0,r.jsx)(n.code,{children:"Text"})," with ",(0,r.jsx)(n.code,{children:"#[derive(Declare)]"}),", it also generates the ",(0,r.jsx)(n.code,{children:"text! { ... }"})," macro, which is essentially equivalent to ",(0,r.jsx)(n.code,{children:"fn_widget! { @Text { ... } }"})," within ",(0,r.jsx)(n.code,{children:"fn_widget!"}),". Note that since it is generated through ",(0,r.jsx)(n.code,{children:"fn_widget!"}),", this approach makes it essentially a function that is lazy. If you create it via ",(0,r.jsx)(n.code,{children:"@text! {}"})," instead of ",(0,r.jsx)(n.code,{children:"@Text {}"}),", you cannot access the ",(0,r.jsx)(n.code,{children:"Text"}),"'s attributes externally."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Ribir also provides the ",(0,r.jsx)(n.code,{children:"#[simple_declare]"})," macro, which generates a simplified Builder for your Widget that eventually returns ",(0,r.jsx)(n.code,{children:"T"}),". This is suitable for Widgets that do not require built-in attributes or complex state management."]}),"\n",(0,r.jsx)(n.h2,{id:"what-is-fatobj",children:"What is FatObj?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"FatObj<T>"})," is a generic struct in Ribir's core library. Its purpose is to temporarily wrap a Widget during the build phase and attach various built-in attributes to it, such as ",(0,r.jsx)(n.code,{children:"margin"}),", ",(0,r.jsx)(n.code,{children:"background"}),", ",(0,r.jsx)(n.code,{children:"on_tap"}),", etc."]}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy Initialization"}),": ",(0,r.jsx)(n.code,{children:"FatObj"})," internally maintains the state of all built-in attributes (like ",(0,r.jsx)(n.code,{children:"margin"}),", ",(0,r.jsx)(n.code,{children:"padding"}),", etc.), but they default to empty. Only when you explicitly use an attribute is the related widget initialized. This ensures that unused features don't bring additional performance overhead."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compose"}),": In the final stage of Widget construction, ",(0,r.jsx)(n.code,{children:"FatObj"})," composes the Widget it wraps with the enabled built-in features (like ",(0,r.jsx)(n.code,{children:"Padding"}),", ",(0,r.jsx)(n.code,{children:"Container"}),", ",(0,r.jsx)(n.code,{children:"MixBuiltin"}),", etc.) into the final Widget tree."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Example: ",(0,r.jsx)(n.code,{children:"Margin(MixBuiltin(Text))"})]}),"\n",(0,r.jsx)(n.h2,{id:"common-built-in-attributes",children:"Common Built-in Attributes"}),"\n",(0,r.jsxs)(n.p,{children:["Built-in attributes are mainly divided into two categories: ",(0,r.jsx)(n.strong,{children:"Properties"})," and ",(0,r.jsx)(n.strong,{children:"Events"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"1-properties",children:"1. Properties"}),"\n",(0,r.jsx)(n.p,{children:"These attributes are used to control the appearance and layout of Widgets."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Layout"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"margin"}),": Sets outer margin."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"padding"}),": Sets inner padding."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"h_align"})," / ",(0,r.jsx)(n.code,{children:"v_align"}),": Sets horizontal/vertical alignment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"anchor"}),": Used for absolute positioning in ",(0,r.jsx)(n.code,{children:"Stack"})," layout."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"global_anchor_x"})," / ",(0,r.jsx)(n.code,{children:"global_anchor_y"}),": Used for positioning relative to the global window."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"clamp"}),": Forces constraints on the Widget's size range (Layout Constraints)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"box_fit"}),": Controls how child elements fit into container space (like fill, contain, etc.)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scrollable"}),": Controls the Widget's scrolling behavior (X-axis, Y-axis, or both)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"layout_box"}),": Controls layout box behavior."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Visual"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"background"}),": Sets background (color or image)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"foreground"}),": Sets foreground (usually overlays on top of content)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"border"}),": Sets border."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"box_shadow"}),": Sets box shadow (outer shadow effect around the box)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"radius"}),": Sets border radius."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"backdrop"}),": Sets backdrop (background effect)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"opacity"}),": Sets opacity."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"visible"}),": Controls visibility."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"transform"}),": Applies graphic transformations (translation, rotation, scaling)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cursor"}),": Sets cursor style when hovering."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"backdrop_filter"}),": Applies background filter effects (like blur)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"filter"}),": Applies visual filter effects (blur, grayscale, brightness, etc.)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"clip_boundary"}),": Whether to clip content beyond boundaries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"painting_style"}),": Sets painting style (fill or stroke)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Text"})," (usually inherited by child nodes):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"text_style"}),": Sets font style."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"text_align"}),": Sets text alignment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"text_line_height"}),": Sets line height."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"font_size"}),": Sets font size."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"font_face"}),": Sets font family."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Other"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"keep_alive"}),": Keeps Widget state even when removed from view."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tooltips"}),": Sets tooltip text."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"disabled"}),": Disables interaction for Widget and its children."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"providers"}),": Sets provider context for the widget."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"class"}),": Applies style classes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"reuse"}),": Reuse Widget by setting the reuse attribute. For local reuse, can be used with (LocalWidgets)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-events",children:"2. Events"}),"\n",(0,r.jsx)(n.p,{children:"These attributes are used to handle user interactions. All event callbacks receive an event object."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pointer Events"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_pointer_down"}),": Triggered when a pointer (mouse button, touch contact, pen) is pressed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_pointer_move"}),": Triggered when a pointer moves."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_pointer_up"}),": Triggered when a pointer is released."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_pointer_cancel"}),": Triggered when a pointer event is cancelled (e.g., touch interruption)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_pointer_enter"}),": Triggered when a pointer enters the widget's area."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_pointer_leave"}),": Triggered when a pointer leaves the widget's area."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_tap"}),": Triggered on a click or tap (press and release sequence)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_tap_capture"}),": Capture phase version of ",(0,r.jsx)(n.code,{children:"on_tap"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_double_tap"}),": Triggered on a double click/tap."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_triple_tap"}),": Triggered on a triple click/tap."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_x_times_tap"}),": Triggered on a specific number of taps."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Wheel Events"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_wheel"}),": Triggered when the mouse wheel is scrolled."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_wheel_capture"}),": Capture phase version of ",(0,r.jsx)(n.code,{children:"on_wheel"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_wheel_changed"}),": Triggered when the wheel delta changes."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Keyboard Events"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_key_down"}),": Triggered when a key is pressed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_key_down_capture"}),": Capture phase version of ",(0,r.jsx)(n.code,{children:"on_key_down"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_key_up"}),": Triggered when a key is released."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_key_up_capture"}),": Capture phase version of ",(0,r.jsx)(n.code,{children:"on_key_up"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Focus Events"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_focus"}),": Triggered when the widget gains focus."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_blur"}),": Triggered when the widget loses focus."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_focus_in"}),": Triggered when the widget or one of its descendants gains focus (bubbles)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_focus_out"}),": Triggered when the widget or one of its descendants loses focus (bubbles)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lifecycle Events"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_mounted"}),": Triggered when the widget is mounted to the widget tree."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_performed_layout"}),": Triggered after the widget has been laid out."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_disposed"}),": Triggered when the widget is removed from the widget tree."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"IME Events"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_ime_pre_edit"}),": Triggered during IME pre-edit (e.g., composing text)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"on_chars"}),": Triggered when text characters are received."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"usage-scenarios",children:"Usage Scenarios"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-1-declaring-a-new-widget",children:"Scenario 1: Declaring a New Widget"}),"\n",(0,r.jsxs)(n.p,{children:["In most cases, widgets are defined with the ",(0,r.jsx)(n.code,{children:"#[derive(Declare)]"})," macro. This means you can directly use built-in attributes when declaring a widget using the ",(0,r.jsx)(n.code,{children:"@"})," syntax."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, the ",(0,r.jsx)(n.code,{children:"Text"})," widget itself does not contain ",(0,r.jsx)(n.code,{children:"margin"})," or ",(0,r.jsx)(n.code,{children:"background"})," fields, but through the ",(0,r.jsx)(n.code,{children:"#[derive(Declare)]"})," and ",(0,r.jsx)(n.code,{children:"FatObj"})," mechanism, you can use them directly during declaration:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\nfn simple_card_traditional() -> Widget<\'static> {\n    fn_widget! {\n        @Text {\n            text: "Hello, Ribir!",\n            // Built-in attributes: Layout\n            margin: EdgeInsets::all(10.),\n            padding: EdgeInsets::symmetrical(10., 5.),\n            h_align: HAlign::Center,\n\n            // Built-in attributes: Visual\n            background: Color::from_u32(0xFFEEAA00),\n            border: Border::all(BorderSide::new(2., Color::BLACK.into())),\n            radius: Radius::all(4.),\n\n            // Built-in attributes: Interaction\n            on_tap: |_: &mut PointerEvent| println!("Card Tapped!"),\n            cursor: CursorIcon::Pointer,\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"scenario-2-wrapping-an-existing-widget",children:"Scenario 2: Wrapping an Existing Widget"}),"\n",(0,r.jsxs)(n.p,{children:["When you need to add built-in attributes to an already constructed Widget instance (e.g., a widget passed as a function argument, or a widget in a variable), you can use the ",(0,r.jsx)(n.code,{children:"@FatObj { ... }"})," syntax."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn simple_card(w: Widget<'static>) -> Widget<'static> {\n    fn_widget! {\n        // Wrap the widget with FatObj to add built-in attributes\n        @FatObj {\n            margin: EdgeInsets::all(10.),\n            padding: EdgeInsets::symmetrical(10., 5.),\n            h_align: HAlign::Center,\n            background: Color::from_u32(0xFFEEAA00),\n            border: Border::all(BorderSide::new(2., Color::BLACK.into())),\n            radius: Radius::all(4.),\n            on_tap: |_: &mut PointerEvent| println!(\"Card Tapped!\"),\n            cursor: CursorIcon::Pointer,\n            // Embed the child widget\n            @ { w }\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This approach is very clear and idiomatic. It is recommended to use ",(0,r.jsx)(n.code,{children:"@FatObj { ... }"})," instead of manually creating ",(0,r.jsx)(n.code,{children:"FatObj::new(w)"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"fatobj-core-mechanics",children:"FatObj Core Mechanics"}),"\n",(0,r.jsx)(n.h3,{id:"inner-wrapping-order-of-built-in-attributes",children:"Inner Wrapping Order of Built-in Attributes"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"FatObj"})," wraps built-in attributes in a fixed order. This order determines the structure of the final widget tree and how attributes interact with each other."]}),"\n",(0,r.jsxs)(n.p,{children:["The wrapping order from ",(0,r.jsx)(n.strong,{children:"inner to outer"})," is as follows (simplified for common attributes):"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content"})," (The widget being wrapped)"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"padding"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"foreground"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"border"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"background"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"backdrop"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"filter"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"clip_boundary"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"box_shadow"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"radius"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"scrollable"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"layout_box"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"providers"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"class"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"clamp"})," (constrained_box)"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"tooltips"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"margin"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"cursor"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Events"})," (",(0,r.jsx)(n.code,{children:"mix_builtin"}),": ",(0,r.jsx)(n.code,{children:"on_tap"}),", ",(0,r.jsx)(n.code,{children:"on_pointer_move"}),", etc.)"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"transform"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"opacity"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"visibility"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"disabled"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"h_align"})," / ",(0,r.jsx)(n.code,{children:"v_align"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"anchor"})," / ",(0,r.jsx)(n.code,{children:"global_anchor"})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"keep_alive"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"reuse"})}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsx)(n.p,{children:"Because wrapping has a fixed order, attributes wrapped in outer layers will affect the scope of attributes in inner layers. If you set multiple built-in attributes and find that the effect does not meet expectations, you can try adjusting the order of the attributes."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Events include Margin"}),": Since ",(0,r.jsx)(n.strong,{children:"Events"})," wrap ",(0,r.jsx)(n.strong,{children:"Margin"}),", the interactive area of a widget includes its margin by default."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transform affects everything"}),": ",(0,r.jsx)(n.code,{children:"transform"})," wraps most visual and layout attributes, so rotating a widget rotates its margin, background, and border as well."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Visibility hides everything"}),": ",(0,r.jsx)(n.code,{children:"visibility"})," is near the outermost layer, so setting it to hidden hides the entire widget including its margin."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"how-to-override-the-order",children:"How to Override the Order?"}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes the default wrapping order doesn't match your requirements. For example, you might want the click area (",(0,r.jsx)(n.code,{children:"on_tap"}),") to ",(0,r.jsx)(n.strong,{children:"exclude"})," the margin."]}),"\n",(0,r.jsxs)(n.p,{children:["Since ",(0,r.jsx)(n.code,{children:"FatObj"})," applies attributes in a fixed order, you can achieve this by manually nesting ",(0,r.jsx)(n.code,{children:"FatObj"}),". You can apply the inner attributes first, and then wrap it with another ",(0,r.jsx)(n.code,{children:"FatObj"})," for the outer attributes."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example: Click area excluding margin"})}),"\n",(0,r.jsx)(n.p,{children:"If you simply write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:'@FatObj {\n    margin: EdgeInsets::all(20.),\n    on_tap: |_| println!("Clicked!"),\n    @ { w }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The structure is ",(0,r.jsx)(n.code,{children:"MixBuiltin(Margin(w))"}),", so clicking the margin triggers the event."]}),"\n",(0,r.jsxs)(n.p,{children:["To exclude the margin from the click area, you want the structure ",(0,r.jsx)(n.code,{children:"Margin(MixBuiltin(w))"}),". You can do this by:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:'fn_widget! {\n    // Outer FatObj handles margin\n    @FatObj {\n        margin: EdgeInsets::all(20.),\n        // Inner FatObj handles the click event\n        @FatObj {\n            on_tap: |_| println!("Clicked inside content (excluding margin)!"),\n            @ { w }\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["By nesting ",(0,r.jsx)(n.code,{children:"FatObj"}),", you have full control over the composition order of attributes."]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-dynamic-access--modification",children:"Advanced: Dynamic Access & Modification"}),"\n",(0,r.jsxs)(n.p,{children:["Built-in attributes (like ",(0,r.jsx)(n.code,{children:"opacity"}),", ",(0,r.jsx)(n.code,{children:"background"}),", ",(0,r.jsx)(n.code,{children:"margin"}),") are properties of the ",(0,r.jsx)(n.code,{children:"FatObj"})," wrapper. In a declarative UI, you typically bind these properties to state during creation. However, ",(0,r.jsx)(n.strong,{children:"if you need to modify them dynamically from code (e.g., inside an event handler) or pipe! the field, you have to access the field's Writer."})]}),"\n",(0,r.jsx)(n.h3,{id:"simple-follower-example-one-component-follows-another",children:"Simple Follower Example (one component follows another)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\n/// A tiny example where `follower`'s `background` follows `leader`'s\n/// `background`. Clicking the `leader` toggles its background color; the\n/// `follower` updates automatically because it binds to `leader`'s writer\n/// via `pipe!($read(...))`.\nfn follower_example() -> Widget<'static> {\n   fn_widget! {\n        // Create stateful handles so we can access built-in attributes.\n        let mut leader = @Text { text: \"Leader (click me)\" };\n\n        // Follower: bind background to leader's background so it follows.\n        let follower = @Text { \n          text: \"Follower (follows leader)\",\n          background: pipe!($read(leader.background()).clone()),\n        };\n\n        let seed = Instant::now();\n        @Column {\n          // Leader: clicking toggles its background color\n          @(leader)  {\n            cursor: CursorIcon::Pointer,\n            on_tap: move |_| {\n              *$write(leader.background()) = Color::from_u32(seed.elapsed().as_millis() as u32).into();\n            },\n          }\n          @ { follower }\n        }\n    }.into_widget()\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Notes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"leader"})," is a stateful handle created with ",(0,r.jsx)(n.code,{children:"@"}),". Its ",(0,r.jsx)(n.code,{children:"on_tap"})," event toggles its ",(0,r.jsx)(n.code,{children:"background"})," using ",(0,r.jsx)(n.code,{children:"$write"})," to update it."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"follower"})," binds its ",(0,r.jsx)(n.code,{children:"background"})," to ",(0,r.jsx)(n.code,{children:"leader"}),"'s background using ",(0,r.jsx)(n.code,{children:"pipe!($read(...)).map(...)"}),", so it updates automatically whenever the leader's background changes."]}),"\n",(0,r.jsx)(n.li,{children:"This pattern is useful when multiple widgets should visually reflect a single source of truth (theme, selection, focus, etc.) without manually propagating events."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"FatObj"})," is the key to Ribir's flexibility. It allows any Widget to have rich common capabilities while keeping the core Widget definition concise. Through built-in attributes, you can quickly build beautiful and interactive UIs without repeatedly implementing these basic features for each Widget."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);