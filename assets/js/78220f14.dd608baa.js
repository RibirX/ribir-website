"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1571],{5757:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var t=i(4848),s=i(8453);const o={sidebar_position:6},l="Layout System",r={id:"concepts/layout",title:"Layout System",description:"Ribir's layout system uses a \"Constraints Down, Size Up\" single-pass model. This is very similar to Flutter's layout model and aims to achieve efficient and flexible UI layout.",source:"@site/docs/concepts/layout.md",sourceDirName:"concepts",slug:"/concepts/layout",permalink:"/docs/next/concepts/layout",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1772087058e3,sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Data Sharing & Events",permalink:"/docs/next/concepts/data_sharing_and_events"},next:{title:"Widget System",permalink:"/docs/next/category/widget-system"}},a={},c=[{value:"Core Principles",id:"core-principles",level:2},{value:"BoxClamp",id:"boxclamp",level:2},{value:"Layout Process",id:"layout-process",level:2},{value:"Using the <code>clamp</code> Attribute to Intervene in Layout",id:"using-the-clamp-attribute-to-intervene-in-layout",level:2},{value:"Common Layout Widgets",id:"common-layout-widgets",level:2},{value:"Custom Layout Example",id:"custom-layout-example",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"layout-system",children:"Layout System"}),"\n",(0,t.jsx)(n.p,{children:"Ribir's layout system uses a \"Constraints Down, Size Up\" single-pass model. This is very similar to Flutter's layout model and aims to achieve efficient and flexible UI layout."}),"\n",(0,t.jsx)(n.h2,{id:"core-principles",children:"Core Principles"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Constraints Down"}),": Parent Widgets pass layout constraints (Constraints) down to child Widgets. These constraints define the minimum and maximum width and height that child Widgets can occupy."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Size Up"}),": Child Widgets calculate their own size based on the received constraints and return the final determined size (Size) to the parent Widget."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parent Sets Position"}),": After receiving the child Widget's size, the parent Widget determines the child Widget's position in its own coordinate system."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"boxclamp",children:"BoxClamp"}),"\n",(0,t.jsxs)(n.p,{children:["Layout constraints are represented by the ",(0,t.jsx)(n.code,{children:"BoxClamp"})," struct. It contains four values:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"min_width"}),", ",(0,t.jsx)(n.code,{children:"max_width"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"min_height"}),", ",(0,t.jsx)(n.code,{children:"max_height"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"BoxClamp"})," defines an allowed size range. The final size of a child Widget must be within this range."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loose Constraints"}),": ",(0,t.jsx)(n.code,{children:"min"})," is 0, ",(0,t.jsx)(n.code,{children:"max"})," is some finite value. Child Widgets can be any size between 0 and max."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tight Constraints"}),": ",(0,t.jsx)(n.code,{children:"min"})," equals ",(0,t.jsx)(n.code,{children:"max"}),". Child Widgets are forced to a specific size."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unbounded Constraints"}),": ",(0,t.jsx)(n.code,{children:"max"})," is infinity. Child Widgets can extend infinitely (usually appears in scrolling containers)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"layout-process",children:"Layout Process"}),"\n",(0,t.jsxs)(n.p,{children:["Each Widget must implement the ",(0,t.jsx)(n.code,{children:"perform_layout"})," method in the ",(0,t.jsx)(n.code,{children:"Render"})," trait:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"fn perform_layout(&self, clamp: BoxClamp, ctx: &mut LayoutCtx) -> Size\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this method, the Widget needs to do three things:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layout children"}),": Iterate through its child nodes, calculate a new ",(0,t.jsx)(n.code,{children:"BoxClamp"})," for each child (based on the incoming ",(0,t.jsx)(n.code,{children:"clamp"})," and its own layout logic), and call ",(0,t.jsx)(n.code,{children:"ctx.perform_child_layout(child, child_clamp)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Determine position"}),": Get the ",(0,t.jsx)(n.code,{children:"Size"})," returned by the child node, and set the child node's position according to the layout logic ",(0,t.jsx)(n.code,{children:"ctx.update_anchor(child, anchor_x, anchor_y)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Return size"}),": Calculate and return its own final ",(0,t.jsx)(n.code,{children:"Size"}),", and this size must satisfy the incoming ",(0,t.jsx)(n.code,{children:"clamp"})," constraint."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"using-the-clamp-attribute-to-intervene-in-layout",children:["Using the ",(0,t.jsx)(n.code,{children:"clamp"})," Attribute to Intervene in Layout"]}),"\n",(0,t.jsxs)(n.p,{children:["Ribir provides a built-in ",(0,t.jsx)(n.code,{children:"clamp"})," attribute that allows you to directly modify the parent constraints a Widget receives when declaring it. This is implemented behind the scenes by wrapping a ",(0,t.jsx)(n.code,{children:"ConstrainedBox"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\nfn example() -> Widget<'static> {\n    fn_widget! {\n        @Container {\n            width: 100.,\n            height: 100.,\n            background: Color::RED,\n            // Force constraint: no matter what constraint the parent gives, the Container's width must be between 50 and 200\n            clamp: BoxClamp {\n                min: Size::new(50., 0.),\n                max: Size::new(200., f32::INFINITY),\n            }\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": The ",(0,t.jsx)(n.code,{children:"clamp"})," attribute's role is to ",(0,t.jsx)(n.strong,{children:"further restrict"})," the constraints passed down from the parent, taking the intersection."]}),"\n",(0,t.jsx)(n.h2,{id:"common-layout-widgets",children:"Common Layout Widgets"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Row / Column"}),": Linear layout. Provides unbounded constraints in the main axis direction (if scrolling or adaptive is allowed), and passes loose or strict constraints in the cross axis."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stack"}),": Stack layout. Passes the same constraints to all non-positioned child nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SizedBox"}),": Forces child nodes to a specific size (by applying Tight Constraints)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"custom-layout-example",children:"Custom Layout Example"}),"\n",(0,t.jsxs)(n.p,{children:["If you need to implement a custom layout Widget, you need to implement the ",(0,t.jsx)(n.code,{children:"Render"})," trait. Here is a simple example that forces child nodes to a fixed size (similar to ",(0,t.jsx)(n.code,{children:"SizedBox"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\n#[derive(SingleChild, Declare, Clone)]\nstruct FixedSizeBox {\n    size: Size,\n}\n\nimpl Render for FixedSizeBox {\n    fn measure(&self, clamp: BoxClamp, ctx: &mut MeasureCtx) -> Size {\n        // 1. Determine the size we want, must be within the parent constraint range\n        let my_size = clamp.clamp(self.size);\n\n        // 2. If there is a child node, force the child node to this size as well\n        if let Some(child) = ctx.single_child() {\n             // Create a tight constraint (Tight Constraint)\n            let child_clamp = BoxClamp { min: my_size, max: my_size };\n\n            // Layout child node\n            ctx.layout_child(child, child_clamp);\n        }\n\n        // 3. Return final size\n        my_size\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["By understanding ",(0,t.jsx)(n.code,{children:"BoxClamp"})," and ",(0,t.jsx)(n.code,{children:"perform_layout"}),", you can fully control the layout behavior of your UI."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);