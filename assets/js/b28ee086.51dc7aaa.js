"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3879],{3951:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var i=n(4848),s=n(8453);const a={sidebar_position:2},r="Quick Start",o={id:"get_started/quick_start",title:"Quick Start",description:"This chapter will introduce you to all the syntax and basic concepts of Ribir.",source:"@site/versioned_docs/version-0.1.x/get_started/quick_start.md",sourceDirName:"get_started",slug:"/get_started/quick_start",permalink:"/docs/0.1.x/get_started/quick_start",draft:!1,unlisted:!1,tags:[],version:"0.1.x",lastUpdatedBy:"Adoo",lastUpdatedAt:1725183625e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Try Ribir",permalink:"/docs/0.1.x/get_started/try_it"},next:{title:"Practice Todos App",permalink:"/docs/0.1.x/category/practice-todos-app"}},d={},c=[{value:"What is a widget?",id:"what-is-a-widget",level:2},{value:"Function widget",id:"function-widget",level:2},{value:"Define widget through function",id:"define-widget-through-function",level:3},{value:"Closure and <code>fn_widget!</code>",id:"closure-and-fn_widget",level:3},{value:"Creating objects using <code>rdl!</code>",id:"creating-objects-using-rdl",level:2},{value:"Declarative creation of objects",id:"declarative-creation-of-objects",level:3},{value:"Composing widgets",id:"composing-widgets",level:2},{value:"Creating objects through expressions",id:"creating-objects-through-expressions",level:3},{value:"The <code>@</code> syntactic sugar",id:"the--syntactic-sugar",level:2},{value:"State -- make data watchable and shareable",id:"state----make-data-watchable-and-shareable",level:2},{value:"The <code>$</code> syntactic sugar",id:"the--syntactic-sugar-1",level:2},{value:"Read and write references to state",id:"read-and-write-references-to-state",level:3},{value:"Automatic sharing of state",id:"automatic-sharing-of-state",level:3},{value:"The priority of syntactic sugar expansion",id:"the-priority-of-syntactic-sugar-expansion",level:3},{value:"<code>Pipe</code> stream -- keep responding to data",id:"pipe-stream----keep-responding-to-data",level:2},{value:"Dynamically render different widgets",id:"dynamically-render-different-widgets",level:3},{value:"Try to keep <code>pipe!</code> containing the smallest expression",id:"try-to-keep-pipe-containing-the-smallest-expression",level:3},{value:"Chain RxRust operators on <code>Pipe</code> stream",id:"chain-rxrust-operators-on-pipe-stream",level:3},{value:"<code>watch!</code> watches for modifications to expressions",id:"watch-watches-for-modifications-to-expressions",level:2},{value:"<code>Compose</code> widget -- describe your data structure",id:"compose-widget----describe-your-data-structure",level:2},{value:"Built-in widgets",id:"built-in-widgets",level:2},{value:"Map, Split and trace the original state",id:"map-split-and-trace-the-original-state",level:2},{value:"Map and split, convert state to sub-state",id:"map-and-split-convert-state-to-sub-state",level:3},{value:"The origin state of the sub-state",id:"the-origin-state-of-the-sub-state",level:3},{value:"The next step",id:"the-next-step",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"quick-start",children:"Quick Start"}),"\n",(0,i.jsx)(t.p,{children:"This chapter will introduce you to all the syntax and basic concepts of Ribir."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"You will learn"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"How to create and compose widgets"}),"\n",(0,i.jsx)(t.li,{children:"How to respond to events and operate data"}),"\n",(0,i.jsx)(t.li,{children:"How to make the view automatically respond to data changes"}),"\n",(0,i.jsx)(t.li,{children:"How to build dynamic widgets"}),"\n",(0,i.jsx)(t.li,{children:"How to map your own data structure to a view"}),"\n",(0,i.jsx)(t.li,{children:"How to use built-in widgets as part of other widgets"}),"\n",(0,i.jsx)(t.li,{children:"How to convert, separate and trace original state -- to facilitate the transfer of state and control the scope of view updates"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"what-is-a-widget",children:"What is a widget?"}),"\n",(0,i.jsxs)(t.p,{children:["In Ribir, the widget is the basic unit for describing the view. In form, it can be a button, a text, a list, a dialog, or even the entire application interface. In code, it can be a function, a closure, or a data object. The type that Ribir can build ",(0,i.jsx)(t.code,{children:"Widget"})," through ",(0,i.jsx)(t.code,{children:"&BuildCtx"})," is called widget. Note the difference between ",(0,i.jsx)(t.code,{children:"Widget"})," and widget, in the context of the entire Ribir, widget is a generic term, and the capitalized ",(0,i.jsx)(t.code,{children:"Widget"})," is a specific widget, which is also the pass for all widgets to enter the view."]}),"\n",(0,i.jsx)(t.p,{children:"If you don't understand the above words very well, don't worry, because you don't need to care about the construction process of the widget at all, and Ribir also prohibits developer interference in this process. You only need to understand that Ribir divides all widgets into four categories:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"function widget"}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Compose"})," widget"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Render"})," widget"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"ComposeChild"})," widget"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This chapter will only introduce function widget and ",(0,i.jsx)(t.code,{children:"Compose"})," widget. Because in most scenarios, these two widgets are enough to meet our needs. As advanced content, we will cover ",(0,i.jsx)(t.code,{children:"Render"})," widgets and ",(0,i.jsx)(t.code,{children:"ComposeChild"})," widgets in ",(0,i.jsx)(t.a,{href:"/docs/0.1.x/understanding_ribir/widget_in_depth",children:"Widget In-depth"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"function-widget",children:"Function widget"}),"\n",(0,i.jsxs)(t.p,{children:["The function or closure that accepts ",(0,i.jsx)(t.code,{children:"&BuildCtx"})," as the input parameter and returns the ",(0,i.jsx)(t.code,{children:"Widget"})," is called a function widget."]}),"\n",(0,i.jsxs)(t.p,{children:["A function widget is the simplest way to define a widget without external state dependencies. In ",(0,i.jsx)(t.a,{href:"./creating_an_application.md",children:"Creating an application"}),", you have seen a function widget of ",(0,i.jsx)(t.code,{children:"Hello world!"}),". In this section, we will continue to introduce it through the example of ",(0,i.jsx)(t.code,{children:"Hello world!"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"define-widget-through-function",children:"Define widget through function"}),"\n",(0,i.jsx)(t.p,{children:"A function widget can be defined directly through a function:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn hello_world(ctx!(): &BuildCtx) -> Widget {\n  rdl!{ Text { text: "Hello World!" } }\n    .widget_build(ctx!())\n}\n\nfn main() { \n  App::run(hello_world);\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["At first, you should find the difference in the parameter declaration (",(0,i.jsx)(t.code,{children:"ctx!(): &BuildCtx"}),") in the function signature. We use ",(0,i.jsx)(t.code,{children:"ctx!()"})," as the parameter name instead of directly giving a name. This is because ",(0,i.jsx)(t.code,{children:"rdl!"})," will unify ",(0,i.jsx)(t.code,{children:"ctx!()"})," as the variable name to refer to ",(0,i.jsx)(t.code,{children:"&BuildCtx"})," inside."]}),"\n",(0,i.jsxs)(t.p,{children:["Then, you can see the next line ",(0,i.jsx)(t.code,{children:'rdl!{ Text { text: "Hello World!" } }'}),", which creates a ",(0,i.jsx)(t.code,{children:"Text"})," with the content ",(0,i.jsx)(t.code,{children:"Hello World!"})," through ",(0,i.jsx)(t.code,{children:"rdl!"}),". The details of ",(0,i.jsx)(t.code,{children:"rdl!"})," will be put aside for now, and will be introduced in detail in the section ",(0,i.jsxs)(t.a,{href:"#creating-objects-using-rdl",children:["Creating objects using ",(0,i.jsx)(t.code,{children:"rdl!"})]}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, build ",(0,i.jsx)(t.code,{children:"Text"})," into ",(0,i.jsx)(t.code,{children:"Widget"})," through the ",(0,i.jsx)(t.code,{children:"widget_build"})," method as the return value of the function."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Tip"}),"\n",(0,i.jsxs)(t.p,{children:["There are multiple procedural macros in Ribir, and ",(0,i.jsx)(t.code,{children:"&BuildCtx"})," is often used as a variable that needs to be passed across macros. In order to simplify this passing process, Ribir uses ",(0,i.jsx)(t.code,{children:"ctx!"})," as the variable name in this case to allow it to be used across macros. So, you will often see the macro ",(0,i.jsx)(t.code,{children:"ctx!"})," in the future."]}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"closure-and-fn_widget",children:["Closure and ",(0,i.jsx)(t.code,{children:"fn_widget!"})]}),"\n",(0,i.jsxs)(t.p,{children:["Because ",(0,i.jsx)(t.code,{children:"hello_world"})," is not called by anyone else, you can rewrite it as a closure:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  let hello_world = |ctx!(): &BuildCtx| {\n    rdl!{ Text { text: "Hello World!" } }\n      .widget_build(ctx!())\n  };\n  App::run(hello_world);\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["For function widgets created through closure, Ribir provides a ",(0,i.jsx)(t.code,{children:"fn_widget!"})," macro to simplify this process. Except for the two syntactic sugars ",(0,i.jsx)(t.code,{children:"@"})," and ",(0,i.jsx)(t.code,{children:"$"})," that we will talk about later in this chapter, you can simply think it will expand the code like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"move |ctx!(): &BuildCtx| -> Widget {\n  {\n    // Your code\n  }\n  .widget_build(ctx!())\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"hello_world"})," example is rewritten with ",(0,i.jsx)(t.code,{children:"fn_widget"}),"!`:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! { \n    rdl!{ Text { text: "Hello World!" } }\n  });\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Do you notice that except for not using ",(0,i.jsx)(t.code,{children:"@"}),", this example is already the same as what you saw in ",(0,i.jsx)(t.a,{href:"./creating_an_application.md",children:"Creating an application"}),"."]}),"\n",(0,i.jsxs)(t.h2,{id:"creating-objects-using-rdl",children:["Creating objects using ",(0,i.jsx)(t.code,{children:"rdl!"})]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"rdl"})," is the abbreviation of Ribir Declarative Language, and the purpose of the ",(0,i.jsx)(t.code,{children:"rdl!"})," macro is to help you create objects in a declarative way."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Notice"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"rdl!"})," does not care about types, it only does processing at the syntax level, so it is not only widgets that can use it."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"declarative-creation-of-objects",children:"Declarative creation of objects"}),"\n",(0,i.jsxs)(t.p,{children:["Although ",(0,i.jsx)(t.code,{children:"rdl!"})," supports any Rust expression, but what we mean by declarative creation of objects, specifically refers to the way of creating objects through structure literals."]}),"\n",(0,i.jsxs)(t.p,{children:["When your expression is a structure literal, ",(0,i.jsx)(t.code,{children:"rdl!"})," will create an object through the ",(0,i.jsx)(t.code,{children:"Declare"})," trait, which requires that the type of the object you create must inherit or implement the ",(0,i.jsx)(t.code,{children:"Declare"})," trait."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\n#[derive(Declare)]\npub struct Counter {\n  #[declare(default = 1usize)]\n  count: usize,\n}\n// `rdl!` only allow to be used in a context with `ctx!(): &BuildCtx` accessible.\n// So we use a function with `ctx!()` parameter to provide this context.\nfn use_rdl(ctx!(): &BuildCtx) {\n  let _ = rdl!{ Counter { } };\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the above example, ",(0,i.jsx)(t.code,{children:"Counter"})," inherits ",(0,i.jsx)(t.code,{children:"Declare"})," and marks the default value of ",(0,i.jsx)(t.code,{children:"count"})," as ",(0,i.jsx)(t.code,{children:"1"}),". So in ",(0,i.jsx)(t.code,{children:"rdl!"}),", you don't need to assign a value to ",(0,i.jsx)(t.code,{children:"count"}),", ",(0,i.jsx)(t.code,{children:"rdl!"})," will assign it a default value of ",(0,i.jsx)(t.code,{children:"1"})," when creating it. ",(0,i.jsx)(t.code,{children:"Declare"})," has some other features, which we will not expand here."]}),"\n",(0,i.jsx)(t.h2,{id:"composing-widgets",children:"Composing widgets"}),"\n",(0,i.jsx)(t.p,{children:"You already know how to create a widget, and now we will compose a simple counter application by nesting widgets in another widget."}),"\n",(0,i.jsxs)(t.p,{children:["You can nest additional ",(0,i.jsx)(t.code,{children:"rdl!"})," instances as children within the widget declared by the structure literal. Please note that child widgets must always be declared after the parent widget's properties. This is a formatting requirement of ",(0,i.jsx)(t.code,{children:"rdl!"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  let counter = fn_widget! { \n    rdl!{ \n      Row {\n        rdl!{ FilledButton {\n          rdl! { Label::new("Increment") }\n        }}\n        rdl!{ H1 { text: "0" } }\n      }\n    }\n  };\n\n  App::run(counter);\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In the above example, we created a ",(0,i.jsx)(t.code,{children:"Row"})," with two child nodes, ",(0,i.jsx)(t.code,{children:"FilledButton"})," and ",(0,i.jsx)(t.code,{children:"H1"}),". These three widgets are already defined in the ",(0,i.jsx)(t.code,{children:"ribir_widgets"})," library."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"rdl!"})," also allows you to declare children for widgets that have already been created:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  let counter = fn_widget! {\n    let row = rdl!{ Row { align_items: Align::Center } };\n\n    rdl!{ \n      $row {\n        rdl!{ FilledButton {\n          rdl! { Label::new("Increment") }\n        }}\n        rdl!{ Text { text: "0" } }\n      }\n    }\n  };\n\n  App::run(counter);\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Do you notice the ",(0,i.jsx)(t.code,{children:"rdl! { $row { ... } }"}),"? It is the same as the structure literal syntax, but with ",(0,i.jsx)(t.code,{children:"$"})," in front of it, it means that it is a variable rather than a type, so it will not create a new widget, but directly use this variable to compose with the child."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Tip"}),"\n",(0,i.jsx)(t.p,{children:"In Ribir, the composition of parent and child widgets is not arbitrary, but subject to type constraints. The parent can restrict the type of the child and implement the composition logic, ensuring the correctness of the composition."}),"\n",(0,i.jsxs)(t.p,{children:["In our example above, ",(0,i.jsx)(t.code,{children:"Row"})," accepts any number and any type of widget, ",(0,i.jsx)(t.code,{children:"Text"})," cannot accept any children, and ",(0,i.jsx)(t.code,{children:"FilledButton"})," is a bit more complicated, it allows to accept a ",(0,i.jsx)(t.code,{children:"Label"})," as its text and a ",(0,i.jsx)(t.code,{children:"Svg"})," as the button icon."]}),"\n",(0,i.jsxs)(t.p,{children:["For how to constrain the child type of the widget, we will introduce it in ",(0,i.jsx)(t.a,{href:"/docs/0.1.x/understanding_ribir/widget_in_depth",children:"Widget In-depth"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"creating-objects-through-expressions",children:"Creating objects through expressions"}),"\n",(0,i.jsxs)(t.p,{children:["Except for creating objects through structure literals, you can also create objects by wrapping any expression with ",(0,i.jsx)(t.code,{children:"rdl! {...}"}),". The advantage of this approach is that you can write any code in ",(0,i.jsx)(t.code,{children:"{...}"})," to create objects. This is very useful in nested composition, and it is only necessary when nesting as a child. The following example shows how to use expressions to create objects in ",(0,i.jsx)(t.code,{children:"rdl"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nlet _ = fn_widget! {\n  rdl!{ Row {\n    rdl!{\n      // you can write any expression here, the result of the expression will be the child\n      if xxx {\n        ...\n      } else {\n        ...\n      }\n    }\n  }}\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"At this point, let's review the previous example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! { \n    rdl!{ Text { text: "Hello World!" } }\n  });\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"I believe you should have fully understood it."}),"\n",(0,i.jsxs)(t.h2,{id:"the--syntactic-sugar",children:["The ",(0,i.jsx)(t.code,{children:"@"})," syntactic sugar"]}),"\n",(0,i.jsxs)(t.p,{children:["In the process of composing widgets, we use a lot of ",(0,i.jsx)(t.code,{children:"rdl!"}),". It allows you to have a clear declarative structure when interacting with Rust syntax (especially complex examples)-when you see ",(0,i.jsx)(t.code,{children:"rdl!"}),", you know that the composition or creation of a widget node has begun; on the other hand, when each node is wrapped with ",(0,i.jsx)(t.code,{children:"rdl!"}),", it looks too long to see the key information at a glance."]}),"\n",(0,i.jsxs)(t.p,{children:["Fortunately, Ribir offers a syntactic sugar, ",(0,i.jsx)(t.code,{children:"@"}),", as an alternative to ",(0,i.jsx)(t.code,{children:"rdl!"}),". In practice, we almost always use ",(0,i.jsx)(t.code,{children:"@"})," instead of ",(0,i.jsx)(t.code,{children:"rdl!"}),". There are three use cases:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"@ Row {...}"})," as a syntactic sugar for structure literals, expanded to ",(0,i.jsx)(t.code,{children:"rdl!{ Row {...} }"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"@ $row {...}"})," as a syntactic sugar for variable structure literals, expanded to ",(0,i.jsx)(t.code,{children:"rdl!{ $row {...} }"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"@ {...}"})," as a syntactic sugar for expressions, expanded to ",(0,i.jsx)(t.code,{children:"rdl!{ ... }"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Now let's rewrite the previous example of Counter using ",(0,i.jsx)(t.code,{children:"@"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    @Row {\n      @FilledButton {\n        @ { Label::new("Increment") }\n      }\n      @Text { text: "0" }\n    }\n  });\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"state----make-data-watchable-and-shareable",children:"State -- make data watchable and shareable"}),"\n",(0,i.jsxs)(t.p,{children:["Although we have created a counter, it always shows ",(0,i.jsx)(t.code,{children:"0"})," and does not respond to the button. In this section, you will learn how to make your counter work through state."]}),"\n",(0,i.jsx)(t.p,{children:"The state is a wrapper that makes data watchable and shareable."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"State = Data + Watchable + Shareable"})}),"\n",(0,i.jsx)(t.p,{children:"The complete life cycle of an interactive Ribir widget is as follows:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Convert your data to a state."}),"\n",(0,i.jsx)(t.li,{children:"Declaratively map the state to build the view."}),"\n",(0,i.jsx)(t.li,{children:"During the interaction, modify the data through the state."}),"\n",(0,i.jsx)(t.li,{children:"Receive data changes through the state, and update the view point-to-point according to the mapping relationship."}),"\n",(0,i.jsx)(t.li,{children:"Repeat steps 3 and 4."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"lifecycle",src:n(3082).A+"",width:"562",height:"391"})}),"\n",(0,i.jsx)(t.p,{children:"Now, let's improve our example by introducing the state."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // Change 1: Create a state through `State::new`\n    let count = State::value(0);\n\n    @Row {\n      @FilledButton {\n        // Change 2: increase the count by 1 when the button is clicked\n        on_tap: move |_| *$count.write() += 1,\n        @ { Label::new("Increment") }\n      }\n      // Change 3: display the count through the state, and keep the view continuously updated.\n      @H1 { text: pipe!($count.to_string()) }\n    }\n  });\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Through the above three changes, the Counter example is complete. But in changes 2 and 3, new things have been introduced -- ",(0,i.jsx)(t.code,{children:"$"})," and ",(0,i.jsx)(t.code,{children:"pipe!"}),". They are very important usages in Ribir, let's introduce them in two sections."]}),"\n",(0,i.jsxs)(t.h2,{id:"the--syntactic-sugar-1",children:["The ",(0,i.jsx)(t.code,{children:"$"})," syntactic sugar"]}),"\n",(0,i.jsxs)(t.p,{children:["There are two important syntactic sugars in Ribir, one is the ",(0,i.jsx)(t.a,{href:"#the-@-syntactic-sugar",children:"@ syntactic sugar"})," we introduced earlier, and the other is the ",(0,i.jsx)(t.code,{children:"$"})," syntactic sugar."]}),"\n",(0,i.jsx)(t.h3,{id:"read-and-write-references-to-state",children:"Read and write references to state"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"$"})," represents a read or write reference to the state that follows it. For example, ",(0,i.jsx)(t.code,{children:"$count"})," represents a read reference to the ",(0,i.jsx)(t.code,{children:"count"})," state, and when it is followed by a ",(0,i.jsx)(t.code,{children:"write()"})," call, it represents a write reference to the ",(0,i.jsx)(t.code,{children:"count"})," state, such as ",(0,i.jsx)(t.code,{children:"$count.write()"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Except for ",(0,i.jsx)(t.code,{children:"write"}),", Ribir also has a ",(0,i.jsx)(t.code,{children:"silent"})," write reference, modifying data through ",(0,i.jsx)(t.code,{children:"silent"})," write reference will not trigger view updates."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"$"})," syntactic sugar for a state is expanded to:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$counter.write()"})," expand to ",(0,i.jsx)(t.code,{children:"counter.write()"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$counter.silent()"})," expand to ",(0,i.jsx)(t.code,{children:"counter.silent()"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"$counter"})," expand to ",(0,i.jsx)(t.code,{children:"counter.read()"})]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"automatic-sharing-of-state",children:"Automatic sharing of state"}),"\n",(0,i.jsxs)(t.p,{children:["When ",(0,i.jsx)(t.code,{children:"$"})," is in a ",(0,i.jsx)(t.code,{children:"move"})," closure, the state it points to will be cloned (read/write), and the closure captures the clone of the state, so ",(0,i.jsx)(t.code,{children:"$"})," allows you to directly use a state and easily complete sharing without having to clone it separately."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"move |_| *$count.write() += 1\n"})}),"\n",(0,i.jsx)(t.p,{children:"Roughly expanded to:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"{\n  let count = count.clone_writer();\n  move |_| *count.write() += 1\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"the-priority-of-syntactic-sugar-expansion",children:"The priority of syntactic sugar expansion"}),"\n",(0,i.jsxs)(t.p,{children:["Do you remember that we also used ",(0,i.jsx)(t.code,{children:"$"})," in ",(0,i.jsx)(t.a,{href:"#composing-widgets",children:"Composing widgets"}),"? For example, ",(0,i.jsx)(t.code,{children:"rdl!{ $row { ... } }"})," or ",(0,i.jsx)(t.code,{children:"@$row { ... }"}),", this is not a reference to state data. Because ",(0,i.jsx)(t.code,{children:"rdl!"})," gives it a different semantics -- declare the parent widget through a variable."]}),"\n",(0,i.jsxs)(t.p,{children:["No matter ",(0,i.jsx)(t.code,{children:"@"})," or ",(0,i.jsx)(t.code,{children:"$"}),", they should first follow the semantics of the macro they are in, and then as a syntactic sugar of Ribir. When we use ",(0,i.jsx)(t.code,{children:"@"})," or ",(0,i.jsx)(t.code,{children:"$"})," in a macro that is not provided by Ribir, they no longer be a syntactic sugar of Ribir, because the external macro may use them with special semantics. For example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nfn_widget!{\n  user_macro! {\n    // `@` is not a syntactic sugar here, its semantics \n    // depends on the implementation of `user_macro!`\n    @Row { ... }\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.h2,{id:"pipe-stream----keep-responding-to-data",children:[(0,i.jsx)(t.code,{children:"Pipe"})," stream -- keep responding to data"]}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"Pipe"})," stream is a continuously updated data stream with an initial value. It can be decomposed into an initial value and an RxRust stream -- the RxRust stream can be subscribed. It is also the only channel for Ribir to update data changes to the view."]}),"\n",(0,i.jsxs)(t.p,{children:["Ribir provides a ",(0,i.jsx)(t.code,{children:"pipe!"})," macro to help you quickly create a ",(0,i.jsx)(t.code,{children:"Pipe"})," stream. It accepts an expression and monitors all states marked with ",(0,i.jsx)(t.code,{children:"$"})," in the expression to trigger the recalculation of the expression."]}),"\n",(0,i.jsxs)(t.p,{children:["In the following example, ",(0,i.jsx)(t.code,{children:"sum"})," is a ",(0,i.jsx)(t.code,{children:"Pipe"})," stream of the sum of ",(0,i.jsx)(t.code,{children:"a"})," and ",(0,i.jsx)(t.code,{children:"b"}),". Whenever ",(0,i.jsx)(t.code,{children:"a"})," or ",(0,i.jsx)(t.code,{children:"b"})," changes, ",(0,i.jsx)(t.code,{children:"sum"})," can send the latest result to its downstream."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nlet a = State::value(0);\nlet b = State::value(0);\n\nlet sum = pipe!(*$a + *$b);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["When declaring an object, you can initialize its property with a ",(0,i.jsx)(t.code,{children:"Pipe"})," stream, so that its property will continue to change with this ",(0,i.jsx)(t.code,{children:"Pipe"})," stream. As we have seen in ",(0,i.jsx)(t.a,{href:"#state----make-data-watchable-and-shareable",children:"State -- make data watchable and shareable"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"  @Text { text: pipe!($count.to_string()) }\n"})}),"\n",(0,i.jsx)(t.h3,{id:"dynamically-render-different-widgets",children:"Dynamically render different widgets"}),"\n",(0,i.jsxs)(t.p,{children:["At this point, all the structures of the views you create are static, and only the properties will change with the data, but the structure of the widget will not change with the data. You can also create a continuously changing widget structure through the ",(0,i.jsx)(t.code,{children:"Pipe"})," stream."]}),"\n",(0,i.jsx)(t.p,{children:"Suppose you have a counter that doesn't display the count with numbers, but instead uses red squares to represent the count:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"box counter",src:n(1932).A+"",width:"862",height:"414"})}),"\n",(0,i.jsx)(t.p,{children:"The code:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run( fn_widget! {\n    let counter = State::value(0);\n\n    @Row {\n      @FilledButton {\n        on_tap: move |_| *$counter.write() += 1,\n        @ { Label::new("Increment") }\n      }\n      @ {\n        pipe!(*$counter).map(move |counter| {\n          (0..counter).map(move |_| {\n            @Container {\n              margin: EdgeInsets::all(2.),\n              size: Size::new(10., 10.),\n              background: Color::RED\n            }\n          })\n        })\n      }\n    }\n  });\n}\n'})}),"\n",(0,i.jsxs)(t.h3,{id:"try-to-keep-pipe-containing-the-smallest-expression",children:["Try to keep ",(0,i.jsx)(t.code,{children:"pipe!"})," containing the smallest expression"]}),"\n",(0,i.jsxs)(t.p,{children:["While ",(0,i.jsx)(t.code,{children:"pipe!"})," can hold any expression, it's best to keep it minimal and use ",(0,i.jsx)(t.code,{children:"map"})," for transformations. This makes it easier to track changes in ",(0,i.jsx)(t.code,{children:"pipe!"})," and avoids unnecessary dependencies in complex expressions. So, in the example above, we write:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"pipe!(*$counter).map(move |counter| {\n  (0..counter).map(move |_| {\n    @Container {\n      margin: EdgeInsets::all(2.),\n      size: Size::new(10., 10.),\n      background: Color::RED\n    }\n  })\n})\n"})}),"\n",(0,i.jsx)(t.p,{children:"instead of:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"pipe!{\n  (0..*$counter).map(move |_| {\n    @Container {\n      margin: EdgeInsets::all(2.),\n      size: Size::new(10., 10.),\n      background: Color::RED\n    }\n  })\n}\n"})}),"\n",(0,i.jsxs)(t.h3,{id:"chain-rxrust-operators-on-pipe-stream",children:["Chain RxRust operators on ",(0,i.jsx)(t.code,{children:"Pipe"})," stream"]}),"\n",(0,i.jsxs)(t.p,{children:["The update push of the ",(0,i.jsx)(t.code,{children:"Pipe"})," stream is built on top of the RxRust stream, so the ",(0,i.jsx)(t.code,{children:"Pipe"})," also provides the ",(0,i.jsx)(t.code,{children:"value_chain"})," method for you to operate on the RxRust stream. Therefore, you can use RxRust operators such as ",(0,i.jsx)(t.code,{children:"filter"}),", ",(0,i.jsx)(t.code,{children:"debounce"})," ",(0,i.jsx)(t.code,{children:"distinct_until_change"})," and other operations to reduce the frequency of updates."]}),"\n",(0,i.jsx)(t.p,{children:"Let's say you have a simple auto-sum example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    let a = State::value(0);\n    let b = State::value(0);\n\n    @Column {\n      @Text { text: pipe!($a.to_string()) }\n      @Text { text: pipe!($b.to_string()) }\n      @Text {\n        text: pipe!((*$a + *$b).to_string())\n          .value_chain(|s| s.distinct_until_changed().box_it()),\n        on_tap: move |_| {\n          *$a.write() += 1;\n          *$b.write() -= 1;\n        }\n      }\n    }\n  });\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the above example, the first two ",(0,i.jsx)(t.code,{children:"Text"})," will be updated with the modification of ",(0,i.jsx)(t.code,{children:"a"})," and ",(0,i.jsx)(t.code,{children:"b"}),", even if the values of ",(0,i.jsx)(t.code,{children:"a"})," and ",(0,i.jsx)(t.code,{children:"b"})," do not change -- such as setting the same value to them. The last ",(0,i.jsx)(t.code,{children:"Text"})," filters out duplicate updates through ",(0,i.jsx)(t.code,{children:"distinct_until_changed"}),", and it will only be updated when the sum of ",(0,i.jsx)(t.code,{children:"a"})," and ",(0,i.jsx)(t.code,{children:"b"})," changes."]}),"\n",(0,i.jsxs)(t.p,{children:["So, when we click on the last ",(0,i.jsx)(t.code,{children:"Text"}),", only the first two ",(0,i.jsx)(t.code,{children:"Text"})," will be marked as updated, and the last ",(0,i.jsx)(t.code,{children:"Text"})," will not."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Tip"}),"\n",(0,i.jsxs)(t.p,{children:["In general, to identify the dynamic parts of the view, simply look for where ",(0,i.jsx)(t.code,{children:"pipe!"})," is used."]}),"\n"]}),"\n",(0,i.jsxs)(t.h2,{id:"watch-watches-for-modifications-to-expressions",children:[(0,i.jsx)(t.code,{children:"watch!"})," watches for modifications to expressions"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"watch!"})," is a macro that watches for modifications in expressions. It accepts an expression and monitors all states marked with ",(0,i.jsx)(t.code,{children:"$"})," in the expression to trigger the recalculation of the expression and push the latest result to the downstream subscriber."]}),"\n",(0,i.jsxs)(t.p,{children:["Both ",(0,i.jsx)(t.code,{children:"watch!"})," and ",(0,i.jsx)(t.code,{children:"pipe!"})," watch changes in expressions and have similar syntax. However, ",(0,i.jsx)(t.code,{children:"pipe!"})," comes with an initial value, acting more like a continuously changing value rather than a simple subscribable data stream. On the other hand, ",(0,i.jsx)(t.code,{children:"watch!"})," is purely a subscribable data stream. As a result, the output of ",(0,i.jsx)(t.code,{children:"pipe!"})," can be used to initialize widget properties, while the output of ",(0,i.jsx)(t.code,{children:"watch!"})," cannot."]}),"\n",(0,i.jsx)(t.p,{children:"In short:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pipe!"})," =  (Initial Value + RxRust Stream)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"watch!"})," = RxRust Stream"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Of course, you can also use ",(0,i.jsx)(t.code,{children:"watch!"})," to implement your counter:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    let count = State::value(0);\n    let display = @H1 { text: "0" };\n\n    watch!(*$count).subscribe(move |v| {\n      $display.write().text = v.to_string().into();\n    });\n\n    @Row {\n      @FilledButton {\n        on_tap: move |_| *$count.write() += 1,\n        @ { Label::new("Increment") }\n      }\n      @{ display }\n    }\n  });\n}\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"compose-widget----describe-your-data-structure",children:[(0,i.jsx)(t.code,{children:"Compose"})," widget -- describe your data structure"]}),"\n",(0,i.jsxs)(t.p,{children:["Typically, in complex real-world scenarios, you can't complete all development tasks just by creating some local data and using simple function widgets. You need your own data structures and use ",(0,i.jsx)(t.code,{children:"Compose"})," widgets to map your data structures to the view."]}),"\n",(0,i.jsxs)(t.p,{children:["Using the ",(0,i.jsx)(t.code,{children:"Compose"})," widget, the Counter example can be rewritten as:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use  ribir::prelude::*;\n\nstruct Counter(usize);\n\nimpl Counter {\n  fn increment(&mut self) {\n    self.0 += 1;\n  }\n}\n\nimpl Compose for Counter {\n  fn compose(this: impl StateWriter<Value = Self>) -> impl WidgetBuilder {\n    fn_widget! {\n      @Row {\n        @FilledButton {\n          on_tap: move |_| $this.write().increment(),\n          @ { Label::new("Increment") }\n        }\n        @H1 { text: pipe!($this.0.to_string()) }\n      }\n    }\n  }\n}\n\nfn main() { \n  App::run(fn_widget!{ Counter(0) }); \n}\n\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In the above example, when you implement ",(0,i.jsx)(t.code,{children:"Compose"})," for ",(0,i.jsx)(t.code,{children:"Counter"}),", ",(0,i.jsx)(t.code,{children:"Counter"})," and all writable states of ",(0,i.jsx)(t.code,{children:"Counter"})," are valid widgets."]}),"\n",(0,i.jsx)(t.h2,{id:"built-in-widgets",children:"Built-in widgets"}),"\n",(0,i.jsx)(t.p,{children:"Ribir provides a set of built-in widgets that allow you to configure basic styles, respond to events, manage lifecycles, and more. The key difference between built-in widgets and regular widgets is that when you create a widget declaratively, you can use the fields and methods of the built-in widget as if they were your own. Ribir will handle the creation and composition of the built-in widgets for you."}),"\n",(0,i.jsxs)(t.p,{children:["Let's take ",(0,i.jsx)(t.code,{children:"Margin"})," as an example. Suppose you want to set a 10-pixel blank margin for a ",(0,i.jsx)(t.code,{children:"Text"}),", the code is as follows:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // Declare `Margin` as the parent of `Text`\n    @Margin {\n      margin: EdgeInsets::all(10.),\n      @Text { text: "Hello World!" }\n    }\n  });\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["But you don't have to explicitly declare a ",(0,i.jsx)(t.code,{children:"Margin"}),", you can write it directly as:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // Use the `Margin::margin` field directly in `Text`\n    @Text {\n      margin: EdgeInsets::all(10.),\n      text: "Hello World!"\n    }\n  });\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"When you create a widget declaratively, you can directly access the fields of the built-in widget, even if you don't explicitly declare them (if you use them in your code, the corresponding built-in widget will be created). For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nfn main() {\n  App::run(fn_widget! {\n    // `margin` is not declared\n    let mut hello_world = @Text { text: "Hello World!" };\n    // But you can still access the `margin` field,\n    // It\'s created with default value when you use it. \n    $hello_world.write().margin = EdgeInsets::all(10.);\n    hello_world\n  });\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Refer to ",(0,i.jsx)(t.a,{href:"/docs/0.1.x/builtin_widget/declare_builtin_fields",children:"Built-in widget list"})," for a list of all built-in fields and methods that can be used as extensions."]}),"\n",(0,i.jsx)(t.h2,{id:"map-split-and-trace-the-original-state",children:"Map, Split and trace the original state"}),"\n",(0,i.jsx)(t.p,{children:"From the previous sections, you have learned:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Modifying the data of the state will cause the dependent view to be updated directly"}),"\n",(0,i.jsxs)(t.li,{children:["You can use ",(0,i.jsx)(t.code,{children:"Compose"})," to map the data to view"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Suppose ",(0,i.jsx)(t.code,{children:"AppData"})," is the data of your entire application, you can use ",(0,i.jsx)(t.code,{children:"Compose"})," to map it to the view. However, if ",(0,i.jsx)(t.code,{children:"AppData"})," is complex, using only one ",(0,i.jsx)(t.code,{children:"Compose"})," to map the view of the entire application will be a disaster in code organization; and the entire application view only depends on one state, which will cause any modification to ",(0,i.jsx)(t.code,{children:"AppData"})," to update all dynamic parts of the view. In most cases, this will cause your application to not get the best interactive performance."]}),"\n",(0,i.jsx)(t.p,{children:"Fortunately, for state management, Ribir provides a mechanism for transformation, splitting, and tracing the origin state. It allows you to start with a complete application state, and then map or split that state into smaller sub-states. These sub-states can be further mapped or split. Within these sub-states, you can use the tracing mechanism to identify their origin state."}),"\n",(0,i.jsx)(t.h3,{id:"map-and-split-convert-state-to-sub-state",children:"Map and split, convert state to sub-state"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"map"})," is to transform a parent state into a sub-state, and the sub-state has the same data as the parent state. Modifying the parent state is equivalent to modifying the sub-state, and vice versa. It only reduces the visible scope of the data, making it easier for you to use or pass only part of the state."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"split"})," is to separate a sub-state from a parent state. The parent and child state also share the same data. The difference is that modifying data through the sub-state will not trigger the views dependent on the parent state to update, and modifying data through the parent state will cause the split sub-state to be invalidated."]}),"\n",(0,i.jsxs)(t.p,{children:["What you need to note is that whether it's ",(0,i.jsx)(t.strong,{children:"map"})," or ",(0,i.jsx)(t.strong,{children:"split"}),", the parent and child state share the same data. Therefore, their modifications to the data will affect each other, but the scope of data modifications they push may be different."]}),"\n",(0,i.jsxs)(t.p,{children:["Read the following example carefully to help you better understand how state ",(0,i.jsx)(t.strong,{children:"map"})," and ",(0,i.jsx)(t.strong,{children:"split"})," work:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nstruct AppData {\n  count: usize,\n}\n\nlet state = State::value(AppData { count: 0 });\nlet map_count = state.map_writer(|d| &d.count, |d| &mut d.count);\nlet split_count = state.split_writer(|d| &d.count, |d| &mut d.count);\n\nwatch!($state.count).subscribe(|_| println!("Parent data"));\nwatch!(*$map_count).subscribe(|_| println!("Child(map) data"));\nwatch!(*$split_count).subscribe(|_| println!("Child(split) data"));\nstate\n  .raw_modifies()\n  .filter(|s| s.contains(ModifyScope::FRAMEWORK))\n  .subscribe(|_| println!("Parent framework"));\nmap_count\n  .raw_modifies()\n  .filter(|s| s.contains(ModifyScope::FRAMEWORK))\n  .subscribe(|_| println!("Child(map) framework"));\nsplit_count\n  .raw_modifies()\n  .filter(|s| s.contains(ModifyScope::FRAMEWORK))\n  .subscribe(|_| println!("Child(split) framework"));\n\n// Modify data through the split sub-state, the data modification push to both the parent and child state subscribers.\n// But only the split sub-state subscribers are pushed framework notifications.\n*split_count.write() = 1;\nAppCtx::run_until_stalled();\n// Print:\n// Parent data\n// Child(map) data\n// Child(split) data\n// Child(split) framework\n\n// When data is modified through the parent state, both the data modification and framework notifications are pushed to the subscribers of the parent and child states. However, the split sub-state becomes invalidated.\nstate.write().count = 3;\n// The push is asynchronous, forcing the push to be sent immediately\nAppCtx::run_until_stalled();\n// Print:\n// Parent data\n// Child(map) data\n// Parent framework\n// Child(map) framework\n\n// Modify data through the map sub-state, the data modification push to both the parent and child state subscribers.\n*map_count.write() = 2;\nAppCtx::run_until_stalled();\n// Print:\n// Parent data\n// Child(map) data\n// Parent framework\n// Child(map) framework\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Because data modification notifications are sent out asynchronously in batches, in the example, for ease of understanding, we call ",(0,i.jsx)(t.code,{children:"AppCtx::run_until_stalled()"})," after each data modification to force the notifications to be sent. However, this should not appear in your actual code."]}),"\n",(0,i.jsxs)(t.p,{children:["If the reader and writer that you map or split from are on the same path, you can use ",(0,i.jsx)(t.code,{children:"map_writer!"})," and ",(0,i.jsx)(t.code,{children:"split_writer!"})," provided by Ribir to simplify your code:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"// let map_count = state.map_writer(|d| &d.count, |d| &mut d.count)\nlet map_count = map_writer!($state.count);\n// let split_count = state.split_writer(|d| &d.count, |d| &mut d.count);\nlet split_count = split_writer!($state.count);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If you only want to get a read-only sub-state, you can use ",(0,i.jsx)(t.code,{children:"map_reader"})," to convert:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",metastring:"ignore",children:"let count_reader = state.map_reader(|d| &d.count);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["However, Ribir does not provide a ",(0,i.jsx)(t.code,{children:"split_reader"}),", because splitting a read-only sub-state is equivalent to converting a read-only sub-state."]}),"\n",(0,i.jsx)(t.h3,{id:"the-origin-state-of-the-sub-state",children:"The origin state of the sub-state"}),"\n",(0,i.jsxs)(t.p,{children:["Any state can get where it comes from through ",(0,i.jsx)(t.code,{children:"origin_reader"})," and ",(0,i.jsx)(t.code,{children:"origin_writer"}),". The origin state of the root state is itself, and the origin state of the sub-state is where it splits from."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nstruct AppData {\n  count: usize,\n}\n\nlet state: State<AppData> = State::value(AppData { count: 0 });\nlet split_count = split_writer!($state.count);\n\n// the root state's origin state is itself\nlet _: &State<AppData> = state.origin_reader();\nlet _: &State<AppData> = state.origin_writer();\n\n// the sub-state's origin state is where it splits from\nlet _: &Writer<AppData> = split_count.origin_reader();\nlet _: &Writer<AppData> = split_count.origin_writer();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"the-next-step",children:"The next step"}),"\n",(0,i.jsxs)(t.p,{children:["You have mastered all the syntax and basic concepts needed to develop a Ribir application. It's time to put them into practice by ",(0,i.jsx)(t.a,{href:"/docs/0.1.x/practice_todos_app/develop_a_todos_app",children:"Practice: Todos application"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1932:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/box_counter-d9866f46c0a2eaeda5ce7b6e6e0bcb2e.gif"},3082:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/data-flows-1a627797ea782bfa0bd8ad81dd04a0f0.svg"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);