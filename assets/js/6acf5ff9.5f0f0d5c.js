"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[221],{1141:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var n=t(4848),s=t(8453);const o={sidebar_position:2},r='Using Ribir without relying on "DSL"',a={id:"understanding_ribir/without_dsl",title:'Using Ribir without relying on "DSL"',description:'Perhaps for the sake of more intuitive debugging, or perhaps to give code a more Rust-like feel, some people will prefer to avoid using too many macros and introducing new syntax, and therefore will be reluctant to use Ribir\'s "DSL".',source:"@site/docs/understanding_ribir/without_dsl.md",sourceDirName:"understanding_ribir",slug:"/understanding_ribir/without_dsl",permalink:"/docs/next/understanding_ribir/without_dsl",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1743000249e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Widgets in Depth",permalink:"/docs/next/understanding_ribir/widget_in_depth"}},d={},l=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Creating widgets via API",id:"creating-widgets-via-api",level:2},{value:"Extending the capabilities of a widget with <code>FatObj</code>",id:"extending-the-capabilities-of-a-widget-with-fatobj",level:3},{value:"Why should we use <code>Declare</code> to create widgets?",id:"why-should-we-use-declare-to-create-widgets",level:3},{value:"Complete Initialization API",id:"complete-initialization-api",level:4},{value:"Support for initialization using <code>pipe!</code> streams",id:"support-for-initialization-using-pipe-streams",level:4},{value:"Support for accessing built-in widget properties",id:"support-for-accessing-built-in-widget-properties",level:4},{value:"Composing child widgets",id:"composing-child-widgets",level:2},{value:"A mix of APIs and macros",id:"a-mix-of-apis-and-macros",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{id:"using-ribir-without-relying-on-dsl",children:'Using Ribir without relying on "DSL"'}),"\n",(0,n.jsxs)(i.p,{children:["Perhaps for the sake of more intuitive debugging, or perhaps to give code a more Rust-like feel, some people will prefer to avoid using too many macros and introducing new syntax, and therefore will be reluctant to use ",(0,n.jsx)(i.a,{href:"https://github.com/RibirX/Ribir",children:"Ribir"}),'\'s "DSL".']}),"\n",(0,n.jsx)(i.p,{children:'This is fine, because Ribir was designed from the beginning to position the "DSL" as a lightweight syntax transformation layer, and you can use Ribir\'s APIs directly to build the UI. You can even choose to use the APIs partly, the macros partly, and the two intertwined in a single code snippet. Everything will be simple and natural.'}),"\n",(0,n.jsx)(i.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,n.jsx)(i.p,{children:"In Ribir:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Views are built with widgets as their base unit."}),"\n",(0,n.jsxs)(i.li,{children:["Widgets are linked to each other by [",(0,n.jsx)(i.strong,{children:"pure composition"}),"](. /widget_in_depth.md#composition) to form new widgets."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Therefore, there are two key points involved in building the UI through the API:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"How to create widgets"}),"\n",(0,n.jsx)(i.li,{children:"How to compose child widgets"}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"creating-widgets-via-api",children:"Creating widgets via API"}),"\n",(0,n.jsxs)(i.p,{children:["As an example, the ",(0,n.jsx)(i.code,{children:"Radio"})," control is defined as follows:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:"use ribir::prelude::*;\n\npub struct Radio {\n  pub selected: bool,\n  pub value: Box<dyn Any>\n}\n"})}),"\n",(0,n.jsx)(i.p,{children:"This is no different than a regular Rust struct, you can just create an object:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nlet radio = Radio { selected: true, value: Box::new(1.) };\n"})}),"\n",(0,n.jsxs)(i.p,{children:["This gives us a selected ",(0,n.jsx)(i.code,{children:"Radio"}),"."]}),"\n",(0,n.jsxs)(i.h3,{id:"extending-the-capabilities-of-a-widget-with-fatobj",children:["Extending the capabilities of a widget with ",(0,n.jsx)(i.code,{children:"FatObj"})]}),"\n",(0,n.jsxs)(i.p,{children:["We've created a ",(0,n.jsx)(i.code,{children:"Radio"}),", but it doesn't provide any API for responding to events."]}),"\n",(0,n.jsx)(i.p,{children:"This is because in Ribir, event response is implemented by a separate widget. Any widget can be composed with it to gain the ability to respond to events."}),"\n",(0,n.jsxs)(i.p,{children:["And, for built-in widgets such as event responses, we can get them without composing them; Ribir provides a ",(0,n.jsx)(i.code,{children:"FatObj<T>"})," generic, which provides the initialization API for all built-in widgets, and wrapping our widgets in it gives the widgets all of the capabilities of the built-in widgets."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nlet radio = Radio { selected: true, value: Box::new(1.) };\nlet radio = FatObj::new(radio)\n  .on_tap(|_| println!("Radio tapped"));\n'})}),"\n",(0,n.jsxs)(i.p,{children:["But in practice, instead of writing it this way, we usually create the widget via the ",(0,n.jsx)(i.code,{children:"Declare"})," trait."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nlet btn: FatObj<State<Radio>> = Radio::declarer()\n  .selected(true)\n  .on_tap(|_| println!("Radio clicked"))\n  .finish();\n'})}),"\n",(0,n.jsxs)(i.h3,{id:"why-should-we-use-declare-to-create-widgets",children:["Why should we use ",(0,n.jsx)(i.code,{children:"Declare"})," to create widgets?"]}),"\n",(0,n.jsx)(i.p,{children:"In the above example, we created the widgets in a similar way to the Builder pattern, which makes the process seem more complicated. However, this approach actually brings more advantages."}),"\n",(0,n.jsx)(i.h4,{id:"complete-initialization-api",children:"Complete Initialization API"}),"\n",(0,n.jsxs)(i.p,{children:["Note that we end up creating a ",(0,n.jsx)(i.code,{children:"FatObj<State<Radio>>"})," instead of a ",(0,n.jsx)(i.code,{children:"Radio"}),". This is because with ",(0,n.jsx)(i.code,{children:"Declare"}),", we can not only configure properties using the method of the same name, but also extend the capabilities of the built-in widget with ",(0,n.jsx)(i.code,{children:"FatObj"}),". As for why we use ",(0,n.jsx)(i.code,{children:"State"}),", it's because ",(0,n.jsx)(i.code,{children:"State"})," allows you to have the state of your control listened to and modified."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nlet mut radio: FatObj<State<Radio>> = Radio::declarer()\n  // We can use the built-in ability\n  .on_tap(|_| println!("taped!"))\n  .finish();\n\nwatch!($radio.selected)\n  .subscribe(|selected| println!("The radio state change to {selected}"));\n'})}),"\n",(0,n.jsxs)(i.p,{children:["Of course, both ",(0,n.jsx)(i.code,{children:"FatObj"})," and ",(0,n.jsx)(i.code,{children:"State"})," only affect the overhead of the final constructed view if you use the capabilities they provide."]}),"\n",(0,n.jsxs)(i.h4,{id:"support-for-initialization-using-pipe-streams",children:["Support for initialization using ",(0,n.jsx)(i.code,{children:"pipe!"})," streams"]}),"\n",(0,n.jsxs)(i.p,{children:["Another advantage of using ",(0,n.jsx)(i.code,{children:"Declare"})," to create widgets is that it supports initializing properties with a ",(0,n.jsx)(i.code,{children:"pipe!"})," stream. Properties initialized by a ",(0,n.jsx)(i.code,{children:"pipe!"})," stream will change as the stream changes. For example, we want to create two ",(0,n.jsx)(i.code,{children:"Radio"}),"s, where the state of one follows the state of the other."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nlet mut radio1: FatObj<State<Radio>> = Radio::declarer()\n  .selected(true)\n  .finish();\nlet radio2 = Radio::declarer()\n  .selected(pipe!($radio1.selected))\n  .finish();\n\nlet _row = Row::declarer()\n  .finish()\n  .with_child(radio1)\n  .with_child(radio2)\n  .into_widget();\n"})}),"\n",(0,n.jsx)(i.h4,{id:"support-for-accessing-built-in-widget-properties",children:"Support for accessing built-in widget properties"}),"\n",(0,n.jsxs)(i.p,{children:["Note that while widgets created with ",(0,n.jsx)(i.code,{children:"Declare"})," can be configured with all built-in capabilities directly, if you need to modify the properties of a built-in widget after initialization, you need to get the corresponding built-in widget before doing so. This is because these built-in widgets are composed on demand. In the following example, we create a button and change its margins when clicked:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:"use ribir::prelude::*;\n\nfn radio_btn() -> Widget<'static> {\n  let mut btn = Radio::declarer().finish();\n  \n  let m = btn.get_margin_widget().clone_writer();\n  btn\n    .on_tap(move |_| m.write().margin = EdgeInsets::all(10.0))\n    .into_widget()\n}\n"})}),"\n",(0,n.jsx)(i.h2,{id:"composing-child-widgets",children:"Composing child widgets"}),"\n",(0,n.jsxs)(i.p,{children:["In Ribir, we use the ",(0,n.jsx)(i.code,{children:"with_child"})," method to compose child widgets with their parent widgets to form new widgets. ",(0,n.jsx)(i.code,{children:"@"})," syntax is also primarily implemented using ",(0,n.jsx)(i.code,{children:"with_child"}),". In fact, you'll probably use it more often than you think."]}),"\n",(0,n.jsxs)(i.p,{children:["For example, for a ",(0,n.jsx)(i.code,{children:"Button"}),", the text it displays is even a child widget, not its property. This is because it can be either a text button or an icon button. If these were properties, then whether you use a text button or an icon button, memory would be allocated for properties you don't need. But if it's a child widget, it can be composed depending on the usage."]}),"\n",(0,n.jsx)(i.p,{children:"Here's an example of a text button and an icon button:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nlet text_btn = Button::declarer()\n  .finish()\n  .with_child("Text Button");\n\nlet icon_btn = Button::declarer()\n  .finish()\n  .with_child(Icon.with_child(named_svgs::get_or_default("search")));\n'})}),"\n",(0,n.jsx)(i.h2,{id:"a-mix-of-apis-and-macros",children:"A mix of APIs and macros"}),"\n",(0,n.jsxs)(i.p,{children:["Ribir's \"DSL\" is not an entirely new language, but rather a set of macros. Each macro can be used as a standalone expression, so you can mix and match them freely. Below we will implement a counter example. We'll create the text for the button and the counter directly through the API, and use ",(0,n.jsx)(i.code,{children:"$"})," when initializing their properties to avoid cloning ",(0,n.jsx)(i.code,{children:"cnt"}),". Finally, we'll combine them into a ",(0,n.jsx)(i.code,{children:"Row"})," using the ",(0,n.jsx)(i.code,{children:"@"})," syntax:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-rust",children:'use ribir::prelude::*;\n\nlet counter = fn_widget! {\n  let cnt = Stateful::new(0);\n  let btn = Button::declarer()\n    .on_tap(move |_| *$cnt.write() += 1)\n    .finish()\n    .with_child("Inc");\n\n  let label = H1::declarer()\n    .text(pipe!($cnt.to_string()))\n    .finish();\n\n  @Row {\n    align_items: Align::Center,\n    @ { btn }\n    @ { label }\n  }\n};\n'})}),"\n",(0,n.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(i.p,{children:'We want everyone who uses Ribir to be able to choose how they want to use it, whether it\'s through the "DSL" or using the API directly, to get the best experience possible.'}),"\n",(0,n.jsx)(i.p,{children:'But what you need to understand is that Ribir\'s "DSL" is not a new language - we don\'t even call it a "DSL". It\'s built entirely on the API we described above, and is just a set of macros designed to make the UI structure clearer and more readable, and to avoid some obvious duplication of code, such as the need to clone State frequently because of move semantics.'}),"\n",(0,n.jsxs)(i.p,{children:["In short, you can choose to use it partially or not at all, everything is free and there is no need to be intimidated by seeing new syntax. Continue your ",(0,n.jsx)(i.a,{href:"/docs/next/get_started/quick_start",children:"Ribir journey"}),"!"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>r,x:()=>a});var n=t(6540);const s={},o=n.createContext(s);function r(e){const i=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(o.Provider,{value:i},e.children)}}}]);