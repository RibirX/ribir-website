"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4470],{5687:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>o});var i=t(4848),s=t(8453);const d={sidebar_position:1},r="Custom Widgets",l={id:"advanced/custom_widgets",title:"Custom Widgets",description:"Custom widgets are the building blocks of any Ribir application. They allow you to encapsulate complex UI functionality, state, and behavior into reusable components that can be composed together to form larger applications.",source:"@site/docs/advanced/custom_widgets.md",sourceDirName:"advanced",slug:"/advanced/custom_widgets",permalink:"/docs/next/advanced/custom_widgets",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"RChangelog[bot]",lastUpdatedAt:1772334978e3,sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Advanced Topics",permalink:"/docs/next/category/advanced-topics"},next:{title:"Animations",permalink:"/docs/next/advanced/animations"}},a={},o=[{value:"Understanding Widget Types",id:"understanding-widget-types",level:2},{value:"Creating Compose Widgets",id:"creating-compose-widgets",level:2},{value:"Basic Structure",id:"basic-structure",level:3},{value:"Using the Custom Widget",id:"using-the-custom-widget",level:3},{value:"Adding Properties to Custom Widgets",id:"adding-properties-to-custom-widgets",level:3},{value:"Creating ComposeChild Widgets",id:"creating-composechild-widgets",level:2},{value:"Understanding the Child System",id:"understanding-the-child-system",level:2},{value:"Template-Based Child Composition",id:"template-based-child-composition",level:3},{value:"Automatic Type Inference",id:"automatic-type-inference",level:4},{value:"Enum Templates: Variant Inference",id:"enum-templates-variant-inference",level:4},{value:"Struct Templates: Field Inference",id:"struct-templates-field-inference",level:4},{value:"Real-World Example: List Widget",id:"real-world-example-list-widget",level:4},{value:"When Explicit Syntax Is Required",id:"when-explicit-syntax-is-required",level:4},{value:"Advanced: Creating Render Widgets",id:"advanced-creating-render-widgets",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"custom-widgets",children:"Custom Widgets"}),"\n",(0,i.jsx)(n.p,{children:"Custom widgets are the building blocks of any Ribir application. They allow you to encapsulate complex UI functionality, state, and behavior into reusable components that can be composed together to form larger applications."}),"\n",(0,i.jsx)(n.h2,{id:"understanding-widget-types",children:"Understanding Widget Types"}),"\n",(0,i.jsx)(n.p,{children:"In Ribir, there are two main categories of custom widgets you can create:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compose Widgets"}),": High-level widgets that build UI by combining other widgets using the ",(0,i.jsx)(n.code,{children:"fn_widget!"})," macro"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Render Widgets"}),": Low-level widgets that handle layout and painting directly"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-compose-widgets",children:"Creating Compose Widgets"}),"\n",(0,i.jsxs)(n.p,{children:["The most common type of custom widget is a ",(0,i.jsx)(n.code,{children:"Compose"})," widget. These widgets don't draw anything themselves; instead, they compose other existing widgets to create something new."]}),"\n",(0,i.jsx)(n.h3,{id:"basic-structure",children:"Basic Structure"}),"\n",(0,i.jsxs)(n.p,{children:["To create a custom ",(0,i.jsx)(n.code,{children:"Compose"})," widget, you need to:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Define a struct with ",(0,i.jsx)(n.code,{children:"#[derive(Declare)]"})]}),"\n",(0,i.jsxs)(n.li,{children:["Implement the ",(0,i.jsx)(n.code,{children:"Compose"})," trait"]}),"\n",(0,i.jsxs)(n.li,{children:["Use the ",(0,i.jsx)(n.code,{children:"fn_widget!"})," macro in the ",(0,i.jsx)(n.code,{children:"compose"})," method"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\n#[declare]\npub struct DocWelcomeCard;\n\nimpl Compose for DocWelcomeCard {\n    fn compose(this: impl StateWriter<Value = Self>) -> Widget<\'static> {\n        fn_widget! {\n            @Column {\n                @Text { text: "Welcome!" }\n                @Button { @Text { text: "Click me" } }\n            }\n        }.into_widget()\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"compose"})," method must return a ",(0,i.jsx)(n.code,{children:"Widget"}),", so we need to call ",(0,i.jsx)(n.code,{children:".into_widget()"})," on the ",(0,i.jsx)(n.code,{children:"fn_widget!"})," result."]}),"\n",(0,i.jsx)(n.h3,{id:"using-the-custom-widget",children:"Using the Custom Widget"}),"\n",(0,i.jsxs)(n.p,{children:["Once you've defined your custom widget, you can use it just like any built-in widget in the ",(0,i.jsx)(n.code,{children:"fn_widget!"})," DSL:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\nfn main() {\n    App::run(fn_widget! {\n        @DocWelcomeCard {}\n    });\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"adding-properties-to-custom-widgets",children:"Adding Properties to Custom Widgets"}),"\n",(0,i.jsx)(n.p,{children:"You can add properties to your custom widget by adding fields to your struct. These fields can be initialized in the DSL using the same syntax as built-in widgets:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:'use ribir::prelude::*;\n\n#[declare]\npub struct DocUserCard {\n    name: String,\n    email: String,\n    #[declare(default)]\n    is_online: bool,\n}\n\nimpl Compose for DocUserCard {\n    fn compose(this: impl StateWriter<Value = Self>) -> Widget<\'static> {\n        fn_widget! {\n            @Container {\n                padding: EdgeInsets::all(16.),\n                border: Border::all(BorderSide::new(1., Color::GRAY.into())),\n                @Column {\n                    @Text {\n                        text: pipe!($read(this).name.clone()),\n                    }\n                    @Text {\n                        text: pipe!($read(this).email.clone()),\n                    }\n                    @Row {\n                        @Text {\n                            text: pipe!($read(this).is_online).map(|v| if v { "Online" } else { "Offline" }),\n                            foreground: pipe!($read(this).is_online).map(|v| if v { Color::GREEN } else { Color::GRAY }),\n                        }\n                        @Container {\n                            size: Size::new(10., 10.),\n                            margin: EdgeInsets::horizontal(8.),\n                            background: pipe!($read(this).is_online).map(|v| if v { Color::GREEN } else { Color::GRAY }),\n                            radius: Radius::all(5.),\n                        }\n                    }\n                }\n            }\n        }.into_widget()\n    }\n}\n\n// Usage:\nfn example() -> Widget<\'static> {\n    fn_widget! {\n        @DocUserCard {\n            name: "John Doe".to_string(),\n            email: "john@example.com".to_string(),\n            is_online: true,\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," When using ",(0,i.jsx)(n.code,{children:"#[derive(Declare)]"}),", fields are ",(0,i.jsx)(n.strong,{children:"mandatory"})," by default. Any field that does not have the ",(0,i.jsx)(n.code,{children:"#[declare(default)]"})," or ",(0,i.jsx)(n.code,{children:"#[declare(skip)]"})," attribute must be provided when declaring the widget. Fields with ",(0,i.jsx)(n.code,{children:"#[declare(default)]"})," are optional, while ",(0,i.jsx)(n.code,{children:"#[declare(skip)]"})," excludes the field from the builder entirely."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-composechild-widgets",children:"Creating ComposeChild Widgets"}),"\n",(0,i.jsxs)(n.p,{children:["Some widgets are designed to wrap or modify a single child widget. These implement the ",(0,i.jsx)(n.code,{children:"ComposeChild"})," trait instead of ",(0,i.jsx)(n.code,{children:"Compose"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"no_run",children:"use ribir::prelude::*;\n\n#[derive(Declare, Clone)]\npub struct DocCardDecorator {\n    #[declare(default)]\n    elevation: f32,\n}\n\nimpl<'a> ComposeChild<'a> for DocCardDecorator {\n    type Child = Widget<'a>;\n\n    fn compose_child(this: impl StateWriter<Value = Self>, child: Self::Child) -> Widget<'a> {\n        fn_widget! {\n            @Container {\n                padding: EdgeInsets::all(16.),\n                background: Color::WHITE,\n                // Add shadow based on elevation\n                transform: pipe!($read(this).elevation).map(|e| {\n                    Transform::scale(1. - e * 0.01, 1. - e * 0.01)\n                }),\n                @ { child }\n            }\n        }.into_widget()\n    }\n}\n\n// Usage:\nfn example() -> Widget<'static> {\n    fn_widget! {\n        @DocCardDecorator {\n            elevation: 4.,\n            @Text { text: \"This text is inside a card\" }\n        }\n    }.into_widget()\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-child-system",children:"Understanding the Child System"}),"\n",(0,i.jsx)(n.p,{children:"Ribir has a strict type system for parent-child relationships that ensures type safety at compile time:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SingleChild"}),": Widgets that accept exactly one child (like ",(0,i.jsx)(n.code,{children:"Padding"}),", ",(0,i.jsx)(n.code,{children:"Container"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"MultiChild"}),": Widgets that accept multiple children (like ",(0,i.jsx)(n.code,{children:"Row"}),", ",(0,i.jsx)(n.code,{children:"Column"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"#[derive(Declare)]"})," macro can automatically implement the appropriate child system trait based on your struct's fields:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:'use ribir::prelude::*;\n\n// For example, our Container Widget can accept a single child:\n#[derive(Declare, SingleChild)]\npub struct Container {\n    pub size: Size,\n}\n\nimpl Render for Container {\n    fn perform_layout(&self, clamp: BoxClamp, ctx: &mut LayoutCtx) -> Size {\n        let size = clamp.clamp(self.size);\n        ctx.perform_single_child_layout(BoxClamp::max_size(size));\n        size\n    }\n\n    #[inline]\n    fn size_affected_by_child(&self) -> bool { false }\n}\n\n// Usage:\nfn example() -> Widget<\'static> {\n    fn_widget! {\n        @Container {\n            size: Size::new(100., 100.),\n            @Text { text: "Hello" } // Can accept a Child Widget\n        }\n    }.into_widget()\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"template-based-child-composition",children:"Template-Based Child Composition"}),"\n",(0,i.jsxs)(n.p,{children:["Templates provide compile-time type safety for widget composition. The ",(0,i.jsx)(n.code,{children:"#[derive(Template)]"})," macro enables ",(0,i.jsx)(n.strong,{children:"automatic type inference"}),", allowing you to write children without explicit type constructors or field names."]}),"\n",(0,i.jsx)(n.h4,{id:"automatic-type-inference",children:"Automatic Type Inference"}),"\n",(0,i.jsx)(n.p,{children:"When using Templates, Ribir automatically infers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Enum variants"})," based on child type (via ",(0,i.jsx)(n.code,{children:"RFrom"})," trait)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Struct fields"})," based on child type (via ",(0,i.jsx)(n.code,{children:"ComposeWithChild"})," trait)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This means you can write ",(0,i.jsx)(n.code,{children:"@{ child }"})," and Ribir will automatically determine where it belongs in your template structure."]}),"\n",(0,i.jsx)(n.h4,{id:"enum-templates-variant-inference",children:"Enum Templates: Variant Inference"}),"\n",(0,i.jsx)(n.p,{children:"Enum templates automatically convert children to the appropriate variant:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\n// Define an enum template with different variant types\n#[derive(Template)]\nenum ContentType {\n    Text(CowArc<str>),\n    Number(i32),\n}\n\n#[declare]\nstruct MyWidget;\n\nimpl<'a> ComposeChild<'a> for MyWidget {\n    type Child = ContentType;\n\n    fn compose_child(_: impl StateWriter<Value = Self>, _child: Self::Child) -> Widget<'a> {\n        Void {}.into_widget()\n    }\n}\n\n// Usage - automatic variant inference:\nlet text_widget = fn_widget! {\n    @MyWidget {\n        @{ \"Hello\" }  // Automatically becomes ContentType::Text\n    }\n};\n\nlet number_widget = fn_widget! {\n    @MyWidget {\n        @{ 42 }  // Automatically becomes ContentType::Number\n    }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"#[derive(Template)]"})," macro generates ",(0,i.jsx)(n.code,{children:"RFrom"})," implementations for each variant, enabling automatic conversion based on the child's type."]}),"\n",(0,i.jsx)(n.h4,{id:"struct-templates-field-inference",children:"Struct Templates: Field Inference"}),"\n",(0,i.jsxs)(n.p,{children:["Struct templates automatically match children to fields by type, ",(0,i.jsx)(n.strong,{children:"regardless of declaration order"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\n// Define custom types for demonstration\nstruct TypeA;\nstruct TypeB;\nstruct TypeC;\n\n#[derive(Template)]\nstruct StructTemplate {\n    a: TypeA,\n    b: Option<TypeB>,\n    c: Option<TypeC>,\n}\n\n#[declare]\nstruct MyContainer;\n\nimpl ComposeChild<'static> for MyContainer {\n    type Child = StructTemplate;\n\n    fn compose_child(_: impl StateWriter<Value = Self>, _child: Self::Child) -> Widget<'static> {\n        Void {}.into_widget()\n    }\n}\n\n// Usage - order-independent field matching:\nlet widget = fn_widget! {\n    @MyContainer {\n        @{ TypeC }  // Matched to 'c' field by type\n        @{ TypeA }  // Matched to 'a' field by type\n        @{ TypeB }  // Matched to 'b' field by type\n    }\n};\n\n// Optional fields can be omitted:\nlet minimal = fn_widget! {\n    @MyContainer {\n        @{ TypeA }  // Only required field\n    }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro generates ",(0,i.jsx)(n.code,{children:"ComposeWithChild"})," implementations with type-specific markers for each field, enabling automatic field assignment."]}),"\n",(0,i.jsx)(n.h4,{id:"real-world-example-list-widget",children:"Real-World Example: List Widget"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"List"})," widget demonstrates practical template usage:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\n// Simplified from widgets/src/list.rs\n#[derive(Template)]\npub enum ListChild<'c> {\n    StandardItem(PairOf<'c, ListItem>),\n    CustomItem(PairOf<'c, ListCustomItem>),\n    Divider(FatObj<Stateful<Divider>>),\n}\n\nimpl<'c> ComposeChild<'c> for List {\n    type Child = Vec<ListChild<'c>>;\n    // ...\n}\n\n// Usage - automatic variant inference:\nlet list = fn_widget! {\n    @List {\n        @ListItem { /* ... */ }      // Automatically becomes ListChild::StandardItem\n        @ListCustomItem { /* ... */ } // Automatically becomes ListChild::CustomItem\n        @Divider {}                   // Automatically becomes ListChild::Divider\n    }\n};\n"})}),"\n",(0,i.jsx)(n.h4,{id:"when-explicit-syntax-is-required",children:"When Explicit Syntax Is Required"}),"\n",(0,i.jsx)(n.p,{children:"Automatic inference works when types are unique. Use explicit syntax when:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multiple fields have the same type"})," - use ",(0,i.jsx)(n.code,{children:"#[template(field)]"})," attribute:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:'#[derive(Template)]\nstruct TwoTexts {\n    #[template(field)]\n    first: CowArc<str>,\n    #[template(field)]\n    second: CowArc<str>,\n}\n\n// Must use explicit field assignment:\nlet widget = fn_widget! {\n    @MyWidget {\n        @TwoTexts {\n            first: "First text",\n            second: "Second text",\n        }\n    }\n};\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-widget template fields"})," (use ",(0,i.jsx)(n.code,{children:"#[template(field)]"})," attribute):"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:'struct TypeA;\n\n#[derive(Template)]\nstruct ConfigTemplate {\n    #[template(field = 5usize)]  // Default value\n    count: usize,\n    #[template(field)]           // Required field\n    name: CowArc<str>,\n    item: TypeA,                 // Child field (auto-matched by type)\n}\n\n// Can override default or omit to use default:\nlet widget = fn_widget! {\n    @MyWidget {\n        @ConfigTemplate {\n            count: 10usize,  // Override default\n            name: "test",    // Required field\n            @{ TypeA }       // Child matched by type\n        }\n    }\n};\n\n// Using default value:\nlet widget2 = fn_widget! {\n    @MyWidget {\n        @ConfigTemplate {\n            name: "test",  // count uses default value of 5\n            @{ TypeA }\n        }\n    }\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"This template system ensures type-safe widget composition while minimizing boilerplate through intelligent type inference."}),"\n",(0,i.jsx)(n.h2,{id:"advanced-creating-render-widgets",children:"Advanced: Creating Render Widgets"}),"\n",(0,i.jsxs)(n.p,{children:["For widgets that need to handle their own layout and painting (like drawing custom shapes or complex interactions), you implement the ",(0,i.jsx)(n.code,{children:"Render"})," trait:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:"ignore",children:"use ribir::prelude::*;\n\n// This is a simple example - more complex Render widgets would\n// implement custom layout and painting logic\n#[declare]\npub struct DocCustomShape {\n    #[declare(default)]\n    color: Color,\n    #[declare(default)]\n    size: Size,\n}\n\nimpl Render for DocCustomShape {\n    fn perform_layout(&self, clamp: BoxClamp, ctx: &mut LayoutCtx) -> Size {\n        // Return the size based on constraints and our desired size\n        clamp.clamp(self.size)\n    }\n\n    fn paint(&self, ctx: &mut PaintingCtx) {\n        // Custom painting logic\n        let rect = Rect::from_size(ctx.box_rect().unwrap().size);\n        ctx\n          .painter()\n          .rect(&rect)\n          .set_fill_brush(self.color)\n          .fill();\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"#[derive(Declare)]"})]}),": This macro generates the builder pattern needed for your widget to work with the ",(0,i.jsx)(n.code,{children:"@"})," syntax"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Field Requirements"}),": Fields are mandatory by default. Use ",(0,i.jsx)(n.code,{children:"#[declare(default)]"})," for optional fields or ",(0,i.jsx)(n.code,{children:"#[declare(skip)]"})," to exclude them from the builder."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State encapsulation"}),": Keep widget state encapsulated and avoid global state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reusability"}),": Design widgets to be reusable and composable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Be mindful of expensive operations in ",(0,i.jsx)(n.code,{children:"perform_layout"})," and ",(0,i.jsx)(n.code,{children:"paint"})," methods"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.p,{children:["Custom widgets form the foundation of any Ribir application. By understanding the difference between ",(0,i.jsx)(n.code,{children:"Compose"})," and ",(0,i.jsx)(n.code,{children:"Render"})," widgets, and how to properly define and use state, you can create powerful, reusable components that leverage the full power of Ribir's declarative UI system."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(6540);const s={},d=i.createContext(s);function r(e){const n=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(d.Provider,{value:n},e.children)}}}]);